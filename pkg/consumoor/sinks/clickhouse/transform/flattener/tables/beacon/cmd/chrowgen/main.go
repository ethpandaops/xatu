package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
)

type multiFlag []string

func (m *multiFlag) String() string {
	return strings.Join(*m, ",")
}

func (m *multiFlag) Set(value string) error {
	value = strings.TrimSpace(value)
	if value == "" {
		return fmt.Errorf("empty type")
	}

	*m = append(*m, value)

	return nil
}

type chTag struct {
	Name      string
	Inline    bool
	OmitEmpty bool
	Prefix    string
	Skip      bool
}

func main() {
	var (
		types multiFlag
		out   string
	)

	flag.Var(&types, "type", "row struct type to generate ToMap for (repeatable)")
	flag.StringVar(&out, "out", "row_to_map_gen.go", "output file")
	flag.Parse()

	if len(types) == 0 {
		failf("at least one -type is required")
	}

	pkgName, structs := parseStructs(".")
	methods := make(map[string][]string, len(types))
	counts := make(map[string]int, len(types))

	for _, typeName := range types {
		lines, count, err := collectAssignments(structs, typeName, "r", "")
		if err != nil {
			failf("collecting fields for %s: %v", typeName, err)
		}

		methods[typeName] = lines
		counts[typeName] = count
	}

	var buf bytes.Buffer
	buf.WriteString("// Code generated by chrowgen; DO NOT EDIT.\n")
	buf.WriteString("\n")
	buf.WriteString("package " + pkgName + "\n")
	buf.WriteString("\n")

	for _, typeName := range types {
		buf.WriteString("func (r " + typeName + ") ToMap() map[string]any {\n")
		buf.WriteString(fmt.Sprintf("\trow := make(map[string]any, %d)\n", counts[typeName]))

		for _, line := range methods[typeName] {
			buf.WriteString("\t" + line + "\n")
		}

		buf.WriteString("\n")
		buf.WriteString("\treturn row\n")
		buf.WriteString("}\n")
		buf.WriteString("\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		failf("formatting generated source: %v", err)
	}

	if err := os.WriteFile(out, formatted, 0o600); err != nil {
		failf("writing %s: %v", out, err)
	}
}

func parseStructs(dir string) (pkgName string, structs map[string]*ast.StructType) {
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(
		fset,
		dir,
		func(info fs.FileInfo) bool {
			name := info.Name()

			return !strings.HasSuffix(name, "_test.go")
		},
		parser.ParseComments,
	)
	if err != nil {
		failf("parsing package: %v", err)
	}

	if len(pkgs) == 0 {
		failf("no package found in %s", dir)
	}

	names := make([]string, 0, len(pkgs))
	for name := range pkgs {
		names = append(names, name)
	}

	sort.Strings(names)

	pkgName = names[0]
	pkg := pkgs[pkgName]

	structs = make(map[string]*ast.StructType, 128)

	for _, file := range pkg.Files {
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				structs[typeSpec.Name.Name] = structType
			}
		}
	}

	return pkgName, structs
}

func collectAssignments(
	structs map[string]*ast.StructType,
	typeName string,
	receiver string,
	columnPrefix string,
) (lines []string, count int, err error) {
	structType, ok := structs[typeName]
	if !ok {
		return nil, 0, fmt.Errorf("type %q not found or not a struct", typeName)
	}

	lines = make([]string, 0, 64)
	count = 0

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			return nil, 0, fmt.Errorf("%s has anonymous field; use named fields", typeName)
		}

		tag, hasTag, err := parseCHTag(field.Tag)
		if err != nil {
			return nil, 0, fmt.Errorf("%s field %s: %w", typeName, field.Names[0].Name, err)
		}

		if !hasTag {
			return nil, 0, fmt.Errorf("%s field %s missing `ch` tag", typeName, field.Names[0].Name)
		}

		if tag.Skip {
			continue
		}

		for _, nameIdent := range field.Names {
			fieldName := nameIdent.Name
			fieldExpr := receiver + "." + fieldName

			if tag.Inline {
				nestedType, err := namedType(field.Type)
				if err != nil {
					return nil, 0, fmt.Errorf("%s field %s: %w", typeName, fieldName, err)
				}

				nestedLines, nestedCount, err := collectAssignments(
					structs,
					nestedType,
					fieldExpr,
					columnPrefix+tag.Prefix,
				)
				if err != nil {
					return nil, 0, err
				}

				lines = append(lines, nestedLines...)
				count += nestedCount

				continue
			}

			columnName := columnPrefix + tag.Name

			if tag.OmitEmpty {
				if !isPointerType(field.Type) {
					return nil, 0, fmt.Errorf("%s field %s: omitempty currently supports pointer fields only", typeName, fieldName)
				}

				lines = append(lines,
					fmt.Sprintf("if %s != nil {", fieldExpr),
					fmt.Sprintf("\trow[%q] = *%s", columnName, fieldExpr),
					"}",
				)
				count++

				continue
			}

			lines = append(lines, fmt.Sprintf("row[%q] = %s", columnName, fieldExpr))
			count++
		}
	}

	return lines, count, nil
}

func parseCHTag(tagLit *ast.BasicLit) (chTag, bool, error) {
	if tagLit == nil {
		return chTag{}, false, nil
	}

	raw, err := strconv.Unquote(tagLit.Value)
	if err != nil {
		return chTag{}, false, fmt.Errorf("invalid tag literal: %w", err)
	}

	value := reflect.StructTag(raw).Get("ch")
	if value == "" {
		return chTag{}, false, nil
	}

	if value == "-" {
		return chTag{Skip: true}, true, nil
	}

	parts := strings.Split(value, ",")
	tag := chTag{
		Name: strings.TrimSpace(parts[0]),
	}

	for _, part := range parts[1:] {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		if !strings.Contains(part, "=") {
			switch part {
			case "inline":
				tag.Inline = true
			case "omitempty":
				tag.OmitEmpty = true
			default:
				return chTag{}, false, fmt.Errorf("unknown tag option %q", part)
			}

			continue
		}

		kv := strings.SplitN(part, "=", 2)
		key := strings.TrimSpace(kv[0])
		val := strings.TrimSpace(kv[1])

		switch key {
		case "prefix":
			tag.Prefix = val
		default:
			return chTag{}, false, fmt.Errorf("unknown tag key %q", key)
		}
	}

	if tag.Inline && tag.Name != "" {
		return chTag{}, false, fmt.Errorf("inline tag must not set a column name")
	}

	if !tag.Inline && tag.Name == "" {
		return chTag{}, false, fmt.Errorf("column name is required unless inline")
	}

	return tag, true, nil
}

func namedType(expr ast.Expr) (string, error) {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name, nil
	case *ast.StarExpr:
		ident, ok := t.X.(*ast.Ident)
		if !ok {
			return "", fmt.Errorf("unsupported pointer type expression %T", t.X)
		}

		return ident.Name, nil
	default:
		return "", fmt.Errorf("unsupported type expression %T", expr)
	}
}

func isPointerType(expr ast.Expr) bool {
	_, ok := expr.(*ast.StarExpr)

	return ok
}

func failf(msg string, args ...any) {
	_, _ = fmt.Fprintf(os.Stderr, "chrowgen: "+msg+"\n", args...)
	os.Exit(1)
}
