// Code generated by chgo-rowgen; DO NOT EDIT.

package libp2p

import (
	"net"

	"github.com/ClickHouse/ch-go/proto"
	"github.com/ethpandaops/xatu/pkg/consumoor/sinks/clickhouse/transform/flattener"
	"github.com/ethpandaops/xatu/pkg/consumoor/sinks/clickhouse/transform/metadata"
)

const libp2pGossipsubAggregateAndProofTableName flattener.TableName = "libp2p_gossipsub_aggregate_and_proof"

type libp2pGossipsubAggregateAndProofBatch struct {
	UpdatedDateTime                           proto.ColDateTime
	Version                                   proto.ColUInt32
	EventDateTime                             proto.ColDateTime64
	Slot                                      proto.ColUInt32
	SlotStartDateTime                         proto.ColDateTime
	Epoch                                     proto.ColUInt32
	EpochStartDateTime                        proto.ColDateTime
	WallclockSlot                             proto.ColUInt32
	WallclockSlotStartDateTime                proto.ColDateTime
	WallclockEpoch                            proto.ColUInt32
	WallclockEpochStartDateTime               proto.ColDateTime
	PropagationSlotStartDiff                  proto.ColUInt32
	PeerIDUniqueKey                           proto.ColInt64
	MessageID                                 proto.ColStr
	MessageSize                               proto.ColUInt32
	TopicLayer                                proto.ColStr
	TopicForkDigestValue                      proto.ColStr
	TopicName                                 proto.ColStr
	TopicEncoding                             proto.ColStr
	AggregatorIndex                           proto.ColUInt32
	CommitteeIndex                            proto.ColStr
	AggregationBits                           proto.ColStr
	BeaconBlockRoot                           flattener.SafeColFixedStr
	SourceEpoch                               proto.ColUInt32
	SourceRoot                                flattener.SafeColFixedStr
	TargetEpoch                               proto.ColUInt32
	TargetRoot                                flattener.SafeColFixedStr
	MetaClientName                            proto.ColStr
	MetaClientID                              proto.ColStr
	MetaClientVersion                         proto.ColStr
	MetaClientImplementation                  proto.ColStr
	MetaClientOS                              proto.ColStr
	MetaClientIP                              *proto.ColNullable[proto.IPv6]
	MetaClientGeoCity                         proto.ColStr
	MetaClientGeoCountry                      proto.ColStr
	MetaClientGeoCountryCode                  proto.ColStr
	MetaClientGeoContinentCode                proto.ColStr
	MetaClientGeoLongitude                    *proto.ColNullable[float64]
	MetaClientGeoLatitude                     *proto.ColNullable[float64]
	MetaClientGeoAutonomousSystemNumber       *proto.ColNullable[uint32]
	MetaClientGeoAutonomousSystemOrganization *proto.ColNullable[string]
	MetaNetworkID                             proto.ColInt32
	MetaNetworkName                           proto.ColStr
	rows                                      int
}

func newlibp2pGossipsubAggregateAndProofBatch() *libp2pGossipsubAggregateAndProofBatch {
	return &libp2pGossipsubAggregateAndProofBatch{
		EventDateTime:                       func() proto.ColDateTime64 { var c proto.ColDateTime64; c.WithPrecision(proto.Precision(3)); return c }(),
		BeaconBlockRoot:                     func() flattener.SafeColFixedStr { var c flattener.SafeColFixedStr; c.SetSize(66); return c }(),
		SourceRoot:                          func() flattener.SafeColFixedStr { var c flattener.SafeColFixedStr; c.SetSize(66); return c }(),
		TargetRoot:                          func() flattener.SafeColFixedStr { var c flattener.SafeColFixedStr; c.SetSize(66); return c }(),
		MetaClientIP:                        new(proto.ColIPv6).Nullable(),
		MetaClientGeoLongitude:              new(proto.ColFloat64).Nullable(),
		MetaClientGeoLatitude:               new(proto.ColFloat64).Nullable(),
		MetaClientGeoAutonomousSystemNumber: new(proto.ColUInt32).Nullable(),
		MetaClientGeoAutonomousSystemOrganization: new(proto.ColStr).Nullable(),
	}
}

func (b *libp2pGossipsubAggregateAndProofBatch) Rows() int {
	return b.rows
}

func (b *libp2pGossipsubAggregateAndProofBatch) appendMetadata(meta *metadata.CommonMetadata) {
	if meta == nil {
		b.MetaClientName.Append("")
		b.MetaClientID.Append("")
		b.MetaClientVersion.Append("")
		b.MetaClientImplementation.Append("")
		b.MetaClientOS.Append("")
		b.MetaClientIP.Append(proto.Nullable[proto.IPv6]{})
		b.MetaClientGeoCity.Append("")
		b.MetaClientGeoCountry.Append("")
		b.MetaClientGeoCountryCode.Append("")
		b.MetaClientGeoContinentCode.Append("")
		b.MetaClientGeoLongitude.Append(proto.Nullable[float64]{})
		b.MetaClientGeoLatitude.Append(proto.Nullable[float64]{})
		b.MetaClientGeoAutonomousSystemNumber.Append(proto.Nullable[uint32]{})
		b.MetaClientGeoAutonomousSystemOrganization.Append(proto.Nullable[string]{})
		b.MetaNetworkID.Append(0)
		b.MetaNetworkName.Append("")
		return
	}

	b.MetaClientName.Append(meta.MetaClientName)
	b.MetaClientID.Append(meta.MetaClientID)
	b.MetaClientVersion.Append(meta.MetaClientVersion)
	b.MetaClientImplementation.Append(meta.MetaClientImplementation)
	b.MetaClientOS.Append(meta.MetaClientOS)
	b.MetaClientIP.Append(proto.NewNullable[proto.IPv6](flattener.ParseIPv6(meta.MetaClientIP)))
	b.MetaClientGeoCity.Append(meta.MetaClientGeoCity)
	b.MetaClientGeoCountry.Append(meta.MetaClientGeoCountry)
	b.MetaClientGeoCountryCode.Append(meta.MetaClientGeoCountryCode)
	b.MetaClientGeoContinentCode.Append(meta.MetaClientGeoContinentCode)
	b.MetaClientGeoLongitude.Append(proto.NewNullable[float64](meta.MetaClientGeoLongitude))
	b.MetaClientGeoLatitude.Append(proto.NewNullable[float64](meta.MetaClientGeoLatitude))
	b.MetaClientGeoAutonomousSystemNumber.Append(proto.NewNullable[uint32](meta.MetaClientGeoAutonomousSystemNumber))
	b.MetaClientGeoAutonomousSystemOrganization.Append(proto.NewNullable[string](meta.MetaClientGeoAutonomousSystemOrganization))
	b.MetaNetworkID.Append(int32(meta.MetaNetworkID))
	b.MetaNetworkName.Append(meta.MetaNetworkName)
}

func (b *libp2pGossipsubAggregateAndProofBatch) Input() proto.Input {
	return proto.Input{
		{Name: "updated_date_time", Data: &b.UpdatedDateTime},
		{Name: "version", Data: &b.Version},
		{Name: "event_date_time", Data: &b.EventDateTime},
		{Name: "slot", Data: &b.Slot},
		{Name: "slot_start_date_time", Data: &b.SlotStartDateTime},
		{Name: "epoch", Data: &b.Epoch},
		{Name: "epoch_start_date_time", Data: &b.EpochStartDateTime},
		{Name: "wallclock_slot", Data: &b.WallclockSlot},
		{Name: "wallclock_slot_start_date_time", Data: &b.WallclockSlotStartDateTime},
		{Name: "wallclock_epoch", Data: &b.WallclockEpoch},
		{Name: "wallclock_epoch_start_date_time", Data: &b.WallclockEpochStartDateTime},
		{Name: "propagation_slot_start_diff", Data: &b.PropagationSlotStartDiff},
		{Name: "peer_id_unique_key", Data: &b.PeerIDUniqueKey},
		{Name: "message_id", Data: &b.MessageID},
		{Name: "message_size", Data: &b.MessageSize},
		{Name: "topic_layer", Data: &b.TopicLayer},
		{Name: "topic_fork_digest_value", Data: &b.TopicForkDigestValue},
		{Name: "topic_name", Data: &b.TopicName},
		{Name: "topic_encoding", Data: &b.TopicEncoding},
		{Name: "aggregator_index", Data: &b.AggregatorIndex},
		{Name: "committee_index", Data: &b.CommitteeIndex},
		{Name: "aggregation_bits", Data: &b.AggregationBits},
		{Name: "beacon_block_root", Data: &b.BeaconBlockRoot},
		{Name: "source_epoch", Data: &b.SourceEpoch},
		{Name: "source_root", Data: &b.SourceRoot},
		{Name: "target_epoch", Data: &b.TargetEpoch},
		{Name: "target_root", Data: &b.TargetRoot},
		{Name: "meta_client_name", Data: &b.MetaClientName},
		{Name: "meta_client_id", Data: &b.MetaClientID},
		{Name: "meta_client_version", Data: &b.MetaClientVersion},
		{Name: "meta_client_implementation", Data: &b.MetaClientImplementation},
		{Name: "meta_client_os", Data: &b.MetaClientOS},
		{Name: "meta_client_ip", Data: b.MetaClientIP},
		{Name: "meta_client_geo_city", Data: &b.MetaClientGeoCity},
		{Name: "meta_client_geo_country", Data: &b.MetaClientGeoCountry},
		{Name: "meta_client_geo_country_code", Data: &b.MetaClientGeoCountryCode},
		{Name: "meta_client_geo_continent_code", Data: &b.MetaClientGeoContinentCode},
		{Name: "meta_client_geo_longitude", Data: b.MetaClientGeoLongitude},
		{Name: "meta_client_geo_latitude", Data: b.MetaClientGeoLatitude},
		{Name: "meta_client_geo_autonomous_system_number", Data: b.MetaClientGeoAutonomousSystemNumber},
		{Name: "meta_client_geo_autonomous_system_organization", Data: b.MetaClientGeoAutonomousSystemOrganization},
		{Name: "meta_network_id", Data: &b.MetaNetworkID},
		{Name: "meta_network_name", Data: &b.MetaNetworkName},
	}
}

func (b *libp2pGossipsubAggregateAndProofBatch) Reset() {
	b.UpdatedDateTime.Reset()
	b.Version.Reset()
	b.EventDateTime.Reset()
	b.Slot.Reset()
	b.SlotStartDateTime.Reset()
	b.Epoch.Reset()
	b.EpochStartDateTime.Reset()
	b.WallclockSlot.Reset()
	b.WallclockSlotStartDateTime.Reset()
	b.WallclockEpoch.Reset()
	b.WallclockEpochStartDateTime.Reset()
	b.PropagationSlotStartDiff.Reset()
	b.PeerIDUniqueKey.Reset()
	b.MessageID.Reset()
	b.MessageSize.Reset()
	b.TopicLayer.Reset()
	b.TopicForkDigestValue.Reset()
	b.TopicName.Reset()
	b.TopicEncoding.Reset()
	b.AggregatorIndex.Reset()
	b.CommitteeIndex.Reset()
	b.AggregationBits.Reset()
	b.BeaconBlockRoot.Reset()
	b.SourceEpoch.Reset()
	b.SourceRoot.Reset()
	b.TargetEpoch.Reset()
	b.TargetRoot.Reset()
	b.MetaClientName.Reset()
	b.MetaClientID.Reset()
	b.MetaClientVersion.Reset()
	b.MetaClientImplementation.Reset()
	b.MetaClientOS.Reset()
	b.MetaClientIP.Reset()
	b.MetaClientGeoCity.Reset()
	b.MetaClientGeoCountry.Reset()
	b.MetaClientGeoCountryCode.Reset()
	b.MetaClientGeoContinentCode.Reset()
	b.MetaClientGeoLongitude.Reset()
	b.MetaClientGeoLatitude.Reset()
	b.MetaClientGeoAutonomousSystemNumber.Reset()
	b.MetaClientGeoAutonomousSystemOrganization.Reset()
	b.MetaNetworkID.Reset()
	b.MetaNetworkName.Reset()
	b.rows = 0
}

func (b *libp2pGossipsubAggregateAndProofBatch) Snapshot() []map[string]any {
	n := b.rows
	out := make([]map[string]any, n)

	for i := 0; i < n; i++ {
		row := make(map[string]any, 43)
		row["updated_date_time"] = b.UpdatedDateTime.Row(i).Unix()
		row["version"] = b.Version.Row(i)
		row["event_date_time"] = b.EventDateTime.Row(i).UnixMilli()
		row["slot"] = b.Slot.Row(i)
		row["slot_start_date_time"] = b.SlotStartDateTime.Row(i).Unix()
		row["epoch"] = b.Epoch.Row(i)
		row["epoch_start_date_time"] = b.EpochStartDateTime.Row(i).Unix()
		row["wallclock_slot"] = b.WallclockSlot.Row(i)
		row["wallclock_slot_start_date_time"] = b.WallclockSlotStartDateTime.Row(i).Unix()
		row["wallclock_epoch"] = b.WallclockEpoch.Row(i)
		row["wallclock_epoch_start_date_time"] = b.WallclockEpochStartDateTime.Row(i).Unix()
		row["propagation_slot_start_diff"] = b.PropagationSlotStartDiff.Row(i)
		row["peer_id_unique_key"] = b.PeerIDUniqueKey.Row(i)
		row["message_id"] = b.MessageID.Row(i)
		row["message_size"] = b.MessageSize.Row(i)
		row["topic_layer"] = b.TopicLayer.Row(i)
		row["topic_fork_digest_value"] = b.TopicForkDigestValue.Row(i)
		row["topic_name"] = b.TopicName.Row(i)
		row["topic_encoding"] = b.TopicEncoding.Row(i)
		row["aggregator_index"] = b.AggregatorIndex.Row(i)
		row["committee_index"] = b.CommitteeIndex.Row(i)
		row["aggregation_bits"] = b.AggregationBits.Row(i)
		row["beacon_block_root"] = string(b.BeaconBlockRoot.Row(i))
		row["source_epoch"] = b.SourceEpoch.Row(i)
		row["source_root"] = string(b.SourceRoot.Row(i))
		row["target_epoch"] = b.TargetEpoch.Row(i)
		row["target_root"] = string(b.TargetRoot.Row(i))
		row["meta_client_name"] = b.MetaClientName.Row(i)
		row["meta_client_id"] = b.MetaClientID.Row(i)
		row["meta_client_version"] = b.MetaClientVersion.Row(i)
		row["meta_client_implementation"] = b.MetaClientImplementation.Row(i)
		row["meta_client_os"] = b.MetaClientOS.Row(i)
		if v := b.MetaClientIP.Row(i); v.Set {
			row["meta_client_ip"] = net.IP(v.Value[:]).String()
		} else {
			row["meta_client_ip"] = nil
		}
		row["meta_client_geo_city"] = b.MetaClientGeoCity.Row(i)
		row["meta_client_geo_country"] = b.MetaClientGeoCountry.Row(i)
		row["meta_client_geo_country_code"] = b.MetaClientGeoCountryCode.Row(i)
		row["meta_client_geo_continent_code"] = b.MetaClientGeoContinentCode.Row(i)
		if v := b.MetaClientGeoLongitude.Row(i); v.Set {
			row["meta_client_geo_longitude"] = v.Value
		} else {
			row["meta_client_geo_longitude"] = nil
		}
		if v := b.MetaClientGeoLatitude.Row(i); v.Set {
			row["meta_client_geo_latitude"] = v.Value
		} else {
			row["meta_client_geo_latitude"] = nil
		}
		if v := b.MetaClientGeoAutonomousSystemNumber.Row(i); v.Set {
			row["meta_client_geo_autonomous_system_number"] = v.Value
		} else {
			row["meta_client_geo_autonomous_system_number"] = nil
		}
		if v := b.MetaClientGeoAutonomousSystemOrganization.Row(i); v.Set {
			row["meta_client_geo_autonomous_system_organization"] = v.Value
		} else {
			row["meta_client_geo_autonomous_system_organization"] = nil
		}
		row["meta_network_id"] = b.MetaNetworkID.Row(i)
		row["meta_network_name"] = b.MetaNetworkName.Row(i)
		out[i] = row
	}

	return out
}
