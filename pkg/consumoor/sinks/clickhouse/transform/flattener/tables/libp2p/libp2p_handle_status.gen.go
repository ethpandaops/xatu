// Code generated by chgo-rowgen; DO NOT EDIT.

package libp2p

import (
	"net"

	"github.com/ClickHouse/ch-go/proto"
	"github.com/ethpandaops/xatu/pkg/consumoor/sinks/clickhouse/transform/flattener"
	"github.com/ethpandaops/xatu/pkg/consumoor/sinks/clickhouse/transform/metadata"
)

const libp2pHandleStatusTableName flattener.TableName = "libp2p_handle_status"

type libp2pHandleStatusBatch struct {
	UpdatedDateTime                           proto.ColDateTime
	EventDateTime                             proto.ColDateTime64
	PeerIDUniqueKey                           proto.ColInt64
	Error                                     *proto.ColNullable[string]
	Protocol                                  proto.ColStr
	Direction                                 *proto.ColNullable[string]
	RequestFinalizedEpoch                     *proto.ColNullable[uint32]
	RequestFinalizedRoot                      *proto.ColNullable[string]
	RequestForkDigest                         proto.ColStr
	RequestHeadRoot                           *proto.ColNullable[[]byte]
	RequestHeadSlot                           *proto.ColNullable[uint32]
	RequestEarliestAvailableSlot              *proto.ColNullable[uint32]
	ResponseFinalizedEpoch                    *proto.ColNullable[uint32]
	ResponseFinalizedRoot                     *proto.ColNullable[[]byte]
	ResponseForkDigest                        proto.ColStr
	ResponseHeadRoot                          *proto.ColNullable[[]byte]
	ResponseHeadSlot                          *proto.ColNullable[uint32]
	ResponseEarliestAvailableSlot             *proto.ColNullable[uint32]
	LatencyMilliseconds                       proto.ColDecimal64
	MetaClientName                            proto.ColStr
	MetaClientID                              proto.ColStr
	MetaClientVersion                         proto.ColStr
	MetaClientImplementation                  proto.ColStr
	MetaClientOS                              proto.ColStr
	MetaClientIP                              *proto.ColNullable[proto.IPv6]
	MetaClientGeoCity                         proto.ColStr
	MetaClientGeoCountry                      proto.ColStr
	MetaClientGeoCountryCode                  proto.ColStr
	MetaClientGeoContinentCode                proto.ColStr
	MetaClientGeoLongitude                    *proto.ColNullable[float64]
	MetaClientGeoLatitude                     *proto.ColNullable[float64]
	MetaClientGeoAutonomousSystemNumber       *proto.ColNullable[uint32]
	MetaClientGeoAutonomousSystemOrganization *proto.ColNullable[string]
	MetaNetworkID                             proto.ColInt32
	MetaNetworkName                           proto.ColStr
	rows                                      int
}

func newlibp2pHandleStatusBatch() *libp2pHandleStatusBatch {
	return &libp2pHandleStatusBatch{
		EventDateTime:                             func() proto.ColDateTime64 { var c proto.ColDateTime64; c.WithPrecision(proto.Precision(3)); return c }(),
		Error:                                     new(proto.ColStr).Nullable(),
		Direction:                                 new(proto.ColStr).Nullable(),
		RequestFinalizedEpoch:                     new(proto.ColUInt32).Nullable(),
		RequestFinalizedRoot:                      new(proto.ColStr).Nullable(),
		RequestHeadRoot:                           flattener.NewNullableFixedStr(66),
		RequestHeadSlot:                           new(proto.ColUInt32).Nullable(),
		RequestEarliestAvailableSlot:              new(proto.ColUInt32).Nullable(),
		ResponseFinalizedEpoch:                    new(proto.ColUInt32).Nullable(),
		ResponseFinalizedRoot:                     flattener.NewNullableFixedStr(66),
		ResponseHeadRoot:                          flattener.NewNullableFixedStr(66),
		ResponseHeadSlot:                          new(proto.ColUInt32).Nullable(),
		ResponseEarliestAvailableSlot:             new(proto.ColUInt32).Nullable(),
		MetaClientIP:                              new(proto.ColIPv6).Nullable(),
		MetaClientGeoLongitude:                    new(proto.ColFloat64).Nullable(),
		MetaClientGeoLatitude:                     new(proto.ColFloat64).Nullable(),
		MetaClientGeoAutonomousSystemNumber:       new(proto.ColUInt32).Nullable(),
		MetaClientGeoAutonomousSystemOrganization: new(proto.ColStr).Nullable(),
	}
}

func (b *libp2pHandleStatusBatch) Rows() int {
	return b.rows
}

func (b *libp2pHandleStatusBatch) appendMetadata(meta *metadata.CommonMetadata) {
	if meta == nil {
		b.MetaClientName.Append("")
		b.MetaClientID.Append("")
		b.MetaClientVersion.Append("")
		b.MetaClientImplementation.Append("")
		b.MetaClientOS.Append("")
		b.MetaClientIP.Append(proto.Nullable[proto.IPv6]{})
		b.MetaClientGeoCity.Append("")
		b.MetaClientGeoCountry.Append("")
		b.MetaClientGeoCountryCode.Append("")
		b.MetaClientGeoContinentCode.Append("")
		b.MetaClientGeoLongitude.Append(proto.Nullable[float64]{})
		b.MetaClientGeoLatitude.Append(proto.Nullable[float64]{})
		b.MetaClientGeoAutonomousSystemNumber.Append(proto.Nullable[uint32]{})
		b.MetaClientGeoAutonomousSystemOrganization.Append(proto.Nullable[string]{})
		b.MetaNetworkID.Append(0)
		b.MetaNetworkName.Append("")
		return
	}

	b.MetaClientName.Append(meta.MetaClientName)
	b.MetaClientID.Append(meta.MetaClientID)
	b.MetaClientVersion.Append(meta.MetaClientVersion)
	b.MetaClientImplementation.Append(meta.MetaClientImplementation)
	b.MetaClientOS.Append(meta.MetaClientOS)
	b.MetaClientIP.Append(proto.NewNullable[proto.IPv6](flattener.ParseIPv6(meta.MetaClientIP)))
	b.MetaClientGeoCity.Append(meta.MetaClientGeoCity)
	b.MetaClientGeoCountry.Append(meta.MetaClientGeoCountry)
	b.MetaClientGeoCountryCode.Append(meta.MetaClientGeoCountryCode)
	b.MetaClientGeoContinentCode.Append(meta.MetaClientGeoContinentCode)
	b.MetaClientGeoLongitude.Append(proto.NewNullable[float64](meta.MetaClientGeoLongitude))
	b.MetaClientGeoLatitude.Append(proto.NewNullable[float64](meta.MetaClientGeoLatitude))
	b.MetaClientGeoAutonomousSystemNumber.Append(proto.NewNullable[uint32](meta.MetaClientGeoAutonomousSystemNumber))
	b.MetaClientGeoAutonomousSystemOrganization.Append(proto.NewNullable[string](meta.MetaClientGeoAutonomousSystemOrganization))
	b.MetaNetworkID.Append(int32(meta.MetaNetworkID))
	b.MetaNetworkName.Append(meta.MetaNetworkName)
}

func (b *libp2pHandleStatusBatch) Input() proto.Input {
	return proto.Input{
		{Name: "updated_date_time", Data: &b.UpdatedDateTime},
		{Name: "event_date_time", Data: &b.EventDateTime},
		{Name: "peer_id_unique_key", Data: &b.PeerIDUniqueKey},
		{Name: "error", Data: b.Error},
		{Name: "protocol", Data: &b.Protocol},
		{Name: "direction", Data: b.Direction},
		{Name: "request_finalized_epoch", Data: b.RequestFinalizedEpoch},
		{Name: "request_finalized_root", Data: b.RequestFinalizedRoot},
		{Name: "request_fork_digest", Data: &b.RequestForkDigest},
		{Name: "request_head_root", Data: b.RequestHeadRoot},
		{Name: "request_head_slot", Data: b.RequestHeadSlot},
		{Name: "request_earliest_available_slot", Data: b.RequestEarliestAvailableSlot},
		{Name: "response_finalized_epoch", Data: b.ResponseFinalizedEpoch},
		{Name: "response_finalized_root", Data: b.ResponseFinalizedRoot},
		{Name: "response_fork_digest", Data: &b.ResponseForkDigest},
		{Name: "response_head_root", Data: b.ResponseHeadRoot},
		{Name: "response_head_slot", Data: b.ResponseHeadSlot},
		{Name: "response_earliest_available_slot", Data: b.ResponseEarliestAvailableSlot},
		{Name: "latency_milliseconds", Data: &flattener.TypedColInput{ColInput: &b.LatencyMilliseconds, CHType: "Decimal(10, 3)"}},
		{Name: "meta_client_name", Data: &b.MetaClientName},
		{Name: "meta_client_id", Data: &b.MetaClientID},
		{Name: "meta_client_version", Data: &b.MetaClientVersion},
		{Name: "meta_client_implementation", Data: &b.MetaClientImplementation},
		{Name: "meta_client_os", Data: &b.MetaClientOS},
		{Name: "meta_client_ip", Data: b.MetaClientIP},
		{Name: "meta_client_geo_city", Data: &b.MetaClientGeoCity},
		{Name: "meta_client_geo_country", Data: &b.MetaClientGeoCountry},
		{Name: "meta_client_geo_country_code", Data: &b.MetaClientGeoCountryCode},
		{Name: "meta_client_geo_continent_code", Data: &b.MetaClientGeoContinentCode},
		{Name: "meta_client_geo_longitude", Data: b.MetaClientGeoLongitude},
		{Name: "meta_client_geo_latitude", Data: b.MetaClientGeoLatitude},
		{Name: "meta_client_geo_autonomous_system_number", Data: b.MetaClientGeoAutonomousSystemNumber},
		{Name: "meta_client_geo_autonomous_system_organization", Data: b.MetaClientGeoAutonomousSystemOrganization},
		{Name: "meta_network_id", Data: &b.MetaNetworkID},
		{Name: "meta_network_name", Data: &b.MetaNetworkName},
	}
}

func (b *libp2pHandleStatusBatch) Reset() {
	b.UpdatedDateTime.Reset()
	b.EventDateTime.Reset()
	b.PeerIDUniqueKey.Reset()
	b.Error.Reset()
	b.Protocol.Reset()
	b.Direction.Reset()
	b.RequestFinalizedEpoch.Reset()
	b.RequestFinalizedRoot.Reset()
	b.RequestForkDigest.Reset()
	b.RequestHeadRoot.Reset()
	b.RequestHeadSlot.Reset()
	b.RequestEarliestAvailableSlot.Reset()
	b.ResponseFinalizedEpoch.Reset()
	b.ResponseFinalizedRoot.Reset()
	b.ResponseForkDigest.Reset()
	b.ResponseHeadRoot.Reset()
	b.ResponseHeadSlot.Reset()
	b.ResponseEarliestAvailableSlot.Reset()
	b.LatencyMilliseconds.Reset()
	b.MetaClientName.Reset()
	b.MetaClientID.Reset()
	b.MetaClientVersion.Reset()
	b.MetaClientImplementation.Reset()
	b.MetaClientOS.Reset()
	b.MetaClientIP.Reset()
	b.MetaClientGeoCity.Reset()
	b.MetaClientGeoCountry.Reset()
	b.MetaClientGeoCountryCode.Reset()
	b.MetaClientGeoContinentCode.Reset()
	b.MetaClientGeoLongitude.Reset()
	b.MetaClientGeoLatitude.Reset()
	b.MetaClientGeoAutonomousSystemNumber.Reset()
	b.MetaClientGeoAutonomousSystemOrganization.Reset()
	b.MetaNetworkID.Reset()
	b.MetaNetworkName.Reset()
	b.rows = 0
}

func (b *libp2pHandleStatusBatch) Snapshot() []map[string]any {
	n := b.rows
	out := make([]map[string]any, n)

	for i := 0; i < n; i++ {
		row := make(map[string]any, 35)
		row["updated_date_time"] = b.UpdatedDateTime.Row(i).Unix()
		row["event_date_time"] = b.EventDateTime.Row(i).UnixMilli()
		row["peer_id_unique_key"] = b.PeerIDUniqueKey.Row(i)
		if v := b.Error.Row(i); v.Set {
			row["error"] = v.Value
		} else {
			row["error"] = nil
		}
		row["protocol"] = b.Protocol.Row(i)
		if v := b.Direction.Row(i); v.Set {
			row["direction"] = v.Value
		} else {
			row["direction"] = nil
		}
		if v := b.RequestFinalizedEpoch.Row(i); v.Set {
			row["request_finalized_epoch"] = v.Value
		} else {
			row["request_finalized_epoch"] = nil
		}
		if v := b.RequestFinalizedRoot.Row(i); v.Set {
			row["request_finalized_root"] = v.Value
		} else {
			row["request_finalized_root"] = nil
		}
		row["request_fork_digest"] = b.RequestForkDigest.Row(i)
		if v := b.RequestHeadRoot.Row(i); v.Set {
			row["request_head_root"] = string(v.Value)
		} else {
			row["request_head_root"] = nil
		}
		if v := b.RequestHeadSlot.Row(i); v.Set {
			row["request_head_slot"] = v.Value
		} else {
			row["request_head_slot"] = nil
		}
		if v := b.RequestEarliestAvailableSlot.Row(i); v.Set {
			row["request_earliest_available_slot"] = v.Value
		} else {
			row["request_earliest_available_slot"] = nil
		}
		if v := b.ResponseFinalizedEpoch.Row(i); v.Set {
			row["response_finalized_epoch"] = v.Value
		} else {
			row["response_finalized_epoch"] = nil
		}
		if v := b.ResponseFinalizedRoot.Row(i); v.Set {
			row["response_finalized_root"] = string(v.Value)
		} else {
			row["response_finalized_root"] = nil
		}
		row["response_fork_digest"] = b.ResponseForkDigest.Row(i)
		if v := b.ResponseHeadRoot.Row(i); v.Set {
			row["response_head_root"] = string(v.Value)
		} else {
			row["response_head_root"] = nil
		}
		if v := b.ResponseHeadSlot.Row(i); v.Set {
			row["response_head_slot"] = v.Value
		} else {
			row["response_head_slot"] = nil
		}
		if v := b.ResponseEarliestAvailableSlot.Row(i); v.Set {
			row["response_earliest_available_slot"] = v.Value
		} else {
			row["response_earliest_available_slot"] = nil
		}
		row["latency_milliseconds"] = flattener.FormatDecimal(int64(b.LatencyMilliseconds.Row(i)), 3)
		row["meta_client_name"] = b.MetaClientName.Row(i)
		row["meta_client_id"] = b.MetaClientID.Row(i)
		row["meta_client_version"] = b.MetaClientVersion.Row(i)
		row["meta_client_implementation"] = b.MetaClientImplementation.Row(i)
		row["meta_client_os"] = b.MetaClientOS.Row(i)
		if v := b.MetaClientIP.Row(i); v.Set {
			row["meta_client_ip"] = net.IP(v.Value[:]).String()
		} else {
			row["meta_client_ip"] = nil
		}
		row["meta_client_geo_city"] = b.MetaClientGeoCity.Row(i)
		row["meta_client_geo_country"] = b.MetaClientGeoCountry.Row(i)
		row["meta_client_geo_country_code"] = b.MetaClientGeoCountryCode.Row(i)
		row["meta_client_geo_continent_code"] = b.MetaClientGeoContinentCode.Row(i)
		if v := b.MetaClientGeoLongitude.Row(i); v.Set {
			row["meta_client_geo_longitude"] = v.Value
		} else {
			row["meta_client_geo_longitude"] = nil
		}
		if v := b.MetaClientGeoLatitude.Row(i); v.Set {
			row["meta_client_geo_latitude"] = v.Value
		} else {
			row["meta_client_geo_latitude"] = nil
		}
		if v := b.MetaClientGeoAutonomousSystemNumber.Row(i); v.Set {
			row["meta_client_geo_autonomous_system_number"] = v.Value
		} else {
			row["meta_client_geo_autonomous_system_number"] = nil
		}
		if v := b.MetaClientGeoAutonomousSystemOrganization.Row(i); v.Set {
			row["meta_client_geo_autonomous_system_organization"] = v.Value
		} else {
			row["meta_client_geo_autonomous_system_organization"] = nil
		}
		row["meta_network_id"] = b.MetaNetworkID.Row(i)
		row["meta_network_name"] = b.MetaNetworkName.Row(i)
		out[i] = row
	}

	return out
}
