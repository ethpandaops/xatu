// Code generated by chgo-rowgen; DO NOT EDIT.

package libp2p

import (
	"net"

	"github.com/ClickHouse/ch-go/proto"
	"github.com/ethpandaops/xatu/pkg/consumoor/sinks/clickhouse/transform/flattener"
	"github.com/ethpandaops/xatu/pkg/consumoor/sinks/clickhouse/transform/metadata"
)

const libp2pRpcDataColumnCustodyProbeTableName flattener.TableName = "libp2p_rpc_data_column_custody_probe"

type libp2pRpcDataColumnCustodyProbeBatch struct {
	UpdatedDateTime                           proto.ColDateTime
	EventDateTime                             proto.ColDateTime64
	Slot                                      proto.ColUInt32
	SlotStartDateTime                         proto.ColDateTime
	Epoch                                     proto.ColUInt32
	EpochStartDateTime                        proto.ColDateTime
	WallclockRequestSlot                      proto.ColUInt32
	WallclockRequestSlotStartDateTime         proto.ColDateTime
	WallclockRequestEpoch                     proto.ColUInt32
	WallclockRequestEpochStartDateTime        proto.ColDateTime
	ColumnIndex                               proto.ColUInt64
	ColumnRowsCount                           proto.ColUInt16
	BeaconBlockRoot                           flattener.SafeColFixedStr
	PeerIDUniqueKey                           proto.ColInt64
	Result                                    proto.ColStr
	ResponseTimeMs                            proto.ColInt32
	Error                                     *proto.ColNullable[string]
	MetaClientName                            proto.ColStr
	MetaClientID                              proto.ColStr
	MetaClientVersion                         proto.ColStr
	MetaClientImplementation                  proto.ColStr
	MetaClientOS                              proto.ColStr
	MetaClientIP                              *proto.ColNullable[proto.IPv6]
	MetaClientGeoCity                         proto.ColStr
	MetaClientGeoCountry                      proto.ColStr
	MetaClientGeoCountryCode                  proto.ColStr
	MetaClientGeoContinentCode                proto.ColStr
	MetaClientGeoLongitude                    *proto.ColNullable[float64]
	MetaClientGeoLatitude                     *proto.ColNullable[float64]
	MetaClientGeoAutonomousSystemNumber       *proto.ColNullable[uint32]
	MetaClientGeoAutonomousSystemOrganization *proto.ColNullable[string]
	MetaNetworkID                             proto.ColInt32
	MetaNetworkName                           proto.ColStr
	MetaLabels                                *proto.ColMap[string, string]
	rows                                      int
}

func newlibp2pRpcDataColumnCustodyProbeBatch() *libp2pRpcDataColumnCustodyProbeBatch {
	return &libp2pRpcDataColumnCustodyProbeBatch{
		EventDateTime:                       func() proto.ColDateTime64 { var c proto.ColDateTime64; c.WithPrecision(proto.Precision(3)); return c }(),
		BeaconBlockRoot:                     func() flattener.SafeColFixedStr { var c flattener.SafeColFixedStr; c.SetSize(66); return c }(),
		Error:                               new(proto.ColStr).Nullable(),
		MetaClientIP:                        new(proto.ColIPv6).Nullable(),
		MetaClientGeoLongitude:              new(proto.ColFloat64).Nullable(),
		MetaClientGeoLatitude:               new(proto.ColFloat64).Nullable(),
		MetaClientGeoAutonomousSystemNumber: new(proto.ColUInt32).Nullable(),
		MetaClientGeoAutonomousSystemOrganization: new(proto.ColStr).Nullable(),
		MetaLabels: proto.NewMap[string, string](new(proto.ColStr), new(proto.ColStr)),
	}
}

func (b *libp2pRpcDataColumnCustodyProbeBatch) Rows() int {
	return b.rows
}

func (b *libp2pRpcDataColumnCustodyProbeBatch) appendMetadata(meta *metadata.CommonMetadata) {
	if meta == nil {
		b.MetaClientName.Append("")
		b.MetaClientID.Append("")
		b.MetaClientVersion.Append("")
		b.MetaClientImplementation.Append("")
		b.MetaClientOS.Append("")
		b.MetaClientIP.Append(proto.Nullable[proto.IPv6]{})
		b.MetaClientGeoCity.Append("")
		b.MetaClientGeoCountry.Append("")
		b.MetaClientGeoCountryCode.Append("")
		b.MetaClientGeoContinentCode.Append("")
		b.MetaClientGeoLongitude.Append(proto.Nullable[float64]{})
		b.MetaClientGeoLatitude.Append(proto.Nullable[float64]{})
		b.MetaClientGeoAutonomousSystemNumber.Append(proto.Nullable[uint32]{})
		b.MetaClientGeoAutonomousSystemOrganization.Append(proto.Nullable[string]{})
		b.MetaNetworkID.Append(0)
		b.MetaNetworkName.Append("")
		b.MetaLabels.Append(nil)
		return
	}

	b.MetaClientName.Append(meta.MetaClientName)
	b.MetaClientID.Append(meta.MetaClientID)
	b.MetaClientVersion.Append(meta.MetaClientVersion)
	b.MetaClientImplementation.Append(meta.MetaClientImplementation)
	b.MetaClientOS.Append(meta.MetaClientOS)
	b.MetaClientIP.Append(proto.NewNullable[proto.IPv6](flattener.ParseIPv6(meta.MetaClientIP)))
	b.MetaClientGeoCity.Append(meta.MetaClientGeoCity)
	b.MetaClientGeoCountry.Append(meta.MetaClientGeoCountry)
	b.MetaClientGeoCountryCode.Append(meta.MetaClientGeoCountryCode)
	b.MetaClientGeoContinentCode.Append(meta.MetaClientGeoContinentCode)
	b.MetaClientGeoLongitude.Append(proto.NewNullable[float64](meta.MetaClientGeoLongitude))
	b.MetaClientGeoLatitude.Append(proto.NewNullable[float64](meta.MetaClientGeoLatitude))
	b.MetaClientGeoAutonomousSystemNumber.Append(proto.NewNullable[uint32](meta.MetaClientGeoAutonomousSystemNumber))
	b.MetaClientGeoAutonomousSystemOrganization.Append(proto.NewNullable[string](meta.MetaClientGeoAutonomousSystemOrganization))
	b.MetaNetworkID.Append(int32(meta.MetaNetworkID))
	b.MetaNetworkName.Append(meta.MetaNetworkName)
	if meta.MetaLabels != nil {
		b.MetaLabels.Append(meta.MetaLabels)
	} else {
		b.MetaLabels.Append(map[string]string{})
	}
}

func (b *libp2pRpcDataColumnCustodyProbeBatch) Input() proto.Input {
	return proto.Input{
		{Name: "updated_date_time", Data: &b.UpdatedDateTime},
		{Name: "event_date_time", Data: &b.EventDateTime},
		{Name: "slot", Data: &b.Slot},
		{Name: "slot_start_date_time", Data: &b.SlotStartDateTime},
		{Name: "epoch", Data: &b.Epoch},
		{Name: "epoch_start_date_time", Data: &b.EpochStartDateTime},
		{Name: "wallclock_request_slot", Data: &b.WallclockRequestSlot},
		{Name: "wallclock_request_slot_start_date_time", Data: &b.WallclockRequestSlotStartDateTime},
		{Name: "wallclock_request_epoch", Data: &b.WallclockRequestEpoch},
		{Name: "wallclock_request_epoch_start_date_time", Data: &b.WallclockRequestEpochStartDateTime},
		{Name: "column_index", Data: &b.ColumnIndex},
		{Name: "column_rows_count", Data: &b.ColumnRowsCount},
		{Name: "beacon_block_root", Data: &b.BeaconBlockRoot},
		{Name: "peer_id_unique_key", Data: &b.PeerIDUniqueKey},
		{Name: "result", Data: &b.Result},
		{Name: "response_time_ms", Data: &b.ResponseTimeMs},
		{Name: "error", Data: b.Error},
		{Name: "meta_client_name", Data: &b.MetaClientName},
		{Name: "meta_client_id", Data: &b.MetaClientID},
		{Name: "meta_client_version", Data: &b.MetaClientVersion},
		{Name: "meta_client_implementation", Data: &b.MetaClientImplementation},
		{Name: "meta_client_os", Data: &b.MetaClientOS},
		{Name: "meta_client_ip", Data: b.MetaClientIP},
		{Name: "meta_client_geo_city", Data: &b.MetaClientGeoCity},
		{Name: "meta_client_geo_country", Data: &b.MetaClientGeoCountry},
		{Name: "meta_client_geo_country_code", Data: &b.MetaClientGeoCountryCode},
		{Name: "meta_client_geo_continent_code", Data: &b.MetaClientGeoContinentCode},
		{Name: "meta_client_geo_longitude", Data: b.MetaClientGeoLongitude},
		{Name: "meta_client_geo_latitude", Data: b.MetaClientGeoLatitude},
		{Name: "meta_client_geo_autonomous_system_number", Data: b.MetaClientGeoAutonomousSystemNumber},
		{Name: "meta_client_geo_autonomous_system_organization", Data: b.MetaClientGeoAutonomousSystemOrganization},
		{Name: "meta_network_id", Data: &b.MetaNetworkID},
		{Name: "meta_network_name", Data: &b.MetaNetworkName},
		{Name: "meta_labels", Data: b.MetaLabels},
	}
}

func (b *libp2pRpcDataColumnCustodyProbeBatch) Reset() {
	b.UpdatedDateTime.Reset()
	b.EventDateTime.Reset()
	b.Slot.Reset()
	b.SlotStartDateTime.Reset()
	b.Epoch.Reset()
	b.EpochStartDateTime.Reset()
	b.WallclockRequestSlot.Reset()
	b.WallclockRequestSlotStartDateTime.Reset()
	b.WallclockRequestEpoch.Reset()
	b.WallclockRequestEpochStartDateTime.Reset()
	b.ColumnIndex.Reset()
	b.ColumnRowsCount.Reset()
	b.BeaconBlockRoot.Reset()
	b.PeerIDUniqueKey.Reset()
	b.Result.Reset()
	b.ResponseTimeMs.Reset()
	b.Error.Reset()
	b.MetaClientName.Reset()
	b.MetaClientID.Reset()
	b.MetaClientVersion.Reset()
	b.MetaClientImplementation.Reset()
	b.MetaClientOS.Reset()
	b.MetaClientIP.Reset()
	b.MetaClientGeoCity.Reset()
	b.MetaClientGeoCountry.Reset()
	b.MetaClientGeoCountryCode.Reset()
	b.MetaClientGeoContinentCode.Reset()
	b.MetaClientGeoLongitude.Reset()
	b.MetaClientGeoLatitude.Reset()
	b.MetaClientGeoAutonomousSystemNumber.Reset()
	b.MetaClientGeoAutonomousSystemOrganization.Reset()
	b.MetaNetworkID.Reset()
	b.MetaNetworkName.Reset()
	b.MetaLabels.Reset()
	b.rows = 0
}

func (b *libp2pRpcDataColumnCustodyProbeBatch) Snapshot() []map[string]any {
	n := b.rows
	out := make([]map[string]any, n)

	for i := 0; i < n; i++ {
		row := make(map[string]any, 34)
		row["updated_date_time"] = b.UpdatedDateTime.Row(i).Unix()
		row["event_date_time"] = b.EventDateTime.Row(i).UnixMilli()
		row["slot"] = b.Slot.Row(i)
		row["slot_start_date_time"] = b.SlotStartDateTime.Row(i).Unix()
		row["epoch"] = b.Epoch.Row(i)
		row["epoch_start_date_time"] = b.EpochStartDateTime.Row(i).Unix()
		row["wallclock_request_slot"] = b.WallclockRequestSlot.Row(i)
		row["wallclock_request_slot_start_date_time"] = b.WallclockRequestSlotStartDateTime.Row(i).Unix()
		row["wallclock_request_epoch"] = b.WallclockRequestEpoch.Row(i)
		row["wallclock_request_epoch_start_date_time"] = b.WallclockRequestEpochStartDateTime.Row(i).Unix()
		row["column_index"] = b.ColumnIndex.Row(i)
		row["column_rows_count"] = b.ColumnRowsCount.Row(i)
		row["beacon_block_root"] = string(b.BeaconBlockRoot.Row(i))
		row["peer_id_unique_key"] = b.PeerIDUniqueKey.Row(i)
		row["result"] = b.Result.Row(i)
		row["response_time_ms"] = b.ResponseTimeMs.Row(i)
		if v := b.Error.Row(i); v.Set {
			row["error"] = v.Value
		} else {
			row["error"] = nil
		}
		row["meta_client_name"] = b.MetaClientName.Row(i)
		row["meta_client_id"] = b.MetaClientID.Row(i)
		row["meta_client_version"] = b.MetaClientVersion.Row(i)
		row["meta_client_implementation"] = b.MetaClientImplementation.Row(i)
		row["meta_client_os"] = b.MetaClientOS.Row(i)
		if v := b.MetaClientIP.Row(i); v.Set {
			row["meta_client_ip"] = net.IP(v.Value[:]).String()
		} else {
			row["meta_client_ip"] = nil
		}
		row["meta_client_geo_city"] = b.MetaClientGeoCity.Row(i)
		row["meta_client_geo_country"] = b.MetaClientGeoCountry.Row(i)
		row["meta_client_geo_country_code"] = b.MetaClientGeoCountryCode.Row(i)
		row["meta_client_geo_continent_code"] = b.MetaClientGeoContinentCode.Row(i)
		if v := b.MetaClientGeoLongitude.Row(i); v.Set {
			row["meta_client_geo_longitude"] = v.Value
		} else {
			row["meta_client_geo_longitude"] = nil
		}
		if v := b.MetaClientGeoLatitude.Row(i); v.Set {
			row["meta_client_geo_latitude"] = v.Value
		} else {
			row["meta_client_geo_latitude"] = nil
		}
		if v := b.MetaClientGeoAutonomousSystemNumber.Row(i); v.Set {
			row["meta_client_geo_autonomous_system_number"] = v.Value
		} else {
			row["meta_client_geo_autonomous_system_number"] = nil
		}
		if v := b.MetaClientGeoAutonomousSystemOrganization.Row(i); v.Set {
			row["meta_client_geo_autonomous_system_organization"] = v.Value
		} else {
			row["meta_client_geo_autonomous_system_organization"] = nil
		}
		row["meta_network_id"] = b.MetaNetworkID.Row(i)
		row["meta_network_name"] = b.MetaNetworkName.Row(i)
		row["meta_labels"] = b.MetaLabels.Row(i)
		out[i] = row
	}

	return out
}
