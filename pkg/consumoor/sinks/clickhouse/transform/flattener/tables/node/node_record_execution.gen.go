// Code generated by chgo-rowgen; DO NOT EDIT.

package node

import (
	"net"

	"github.com/ClickHouse/ch-go/proto"
	"github.com/ethpandaops/xatu/pkg/consumoor/sinks/clickhouse/transform/flattener"
	"github.com/ethpandaops/xatu/pkg/consumoor/sinks/clickhouse/transform/metadata"
)

const nodeRecordExecutionTableName flattener.TableName = "node_record_execution"

type nodeRecordExecutionBatch struct {
	UpdatedDateTime                           proto.ColDateTime
	EventDateTime                             proto.ColDateTime64
	Enr                                       proto.ColStr
	Name                                      proto.ColStr
	Version                                   proto.ColStr
	VersionMajor                              proto.ColStr
	VersionMinor                              proto.ColStr
	VersionPatch                              proto.ColStr
	Implementation                            proto.ColStr
	Capabilities                              *proto.ColArr[string]
	ProtocolVersion                           proto.ColStr
	TotalDifficulty                           proto.ColStr
	Head                                      proto.ColStr
	Genesis                                   proto.ColStr
	ForkIDHash                                proto.ColStr
	ForkIDNext                                proto.ColStr
	NodeID                                    proto.ColStr
	IP                                        *proto.ColNullable[proto.IPv6]
	Tcp                                       *proto.ColNullable[uint16]
	Udp                                       *proto.ColNullable[uint16]
	HasIpv6                                   proto.ColBool
	GeoCity                                   proto.ColStr
	GeoCountry                                proto.ColStr
	GeoCountryCode                            proto.ColStr
	GeoContinentCode                          proto.ColStr
	GeoLongitude                              *proto.ColNullable[float64]
	GeoLatitude                               *proto.ColNullable[float64]
	GeoAutonomousSystemNumber                 *proto.ColNullable[uint32]
	GeoAutonomousSystemOrganization           *proto.ColNullable[string]
	MetaClientName                            proto.ColStr
	MetaClientID                              proto.ColStr
	MetaClientVersion                         proto.ColStr
	MetaClientImplementation                  proto.ColStr
	MetaClientOS                              proto.ColStr
	MetaClientIP                              *proto.ColNullable[proto.IPv6]
	MetaClientGeoCity                         proto.ColStr
	MetaClientGeoCountry                      proto.ColStr
	MetaClientGeoCountryCode                  proto.ColStr
	MetaClientGeoContinentCode                proto.ColStr
	MetaClientGeoLongitude                    *proto.ColNullable[float64]
	MetaClientGeoLatitude                     *proto.ColNullable[float64]
	MetaClientGeoAutonomousSystemNumber       *proto.ColNullable[uint32]
	MetaClientGeoAutonomousSystemOrganization *proto.ColNullable[string]
	MetaNetworkID                             proto.ColInt32
	MetaNetworkName                           proto.ColStr
	MetaLabels                                *proto.ColMap[string, string]
	rows                                      int
}

func newnodeRecordExecutionBatch() *nodeRecordExecutionBatch {
	return &nodeRecordExecutionBatch{
		EventDateTime:                       func() proto.ColDateTime64 { var c proto.ColDateTime64; c.WithPrecision(proto.Precision(3)); return c }(),
		Capabilities:                        proto.NewArray[string](new(proto.ColStr)),
		IP:                                  new(proto.ColIPv6).Nullable(),
		Tcp:                                 new(proto.ColUInt16).Nullable(),
		Udp:                                 new(proto.ColUInt16).Nullable(),
		GeoLongitude:                        new(proto.ColFloat64).Nullable(),
		GeoLatitude:                         new(proto.ColFloat64).Nullable(),
		GeoAutonomousSystemNumber:           new(proto.ColUInt32).Nullable(),
		GeoAutonomousSystemOrganization:     new(proto.ColStr).Nullable(),
		MetaClientIP:                        new(proto.ColIPv6).Nullable(),
		MetaClientGeoLongitude:              new(proto.ColFloat64).Nullable(),
		MetaClientGeoLatitude:               new(proto.ColFloat64).Nullable(),
		MetaClientGeoAutonomousSystemNumber: new(proto.ColUInt32).Nullable(),
		MetaClientGeoAutonomousSystemOrganization: new(proto.ColStr).Nullable(),
		MetaLabels: proto.NewMap[string, string](new(proto.ColStr), new(proto.ColStr)),
	}
}

func (b *nodeRecordExecutionBatch) Rows() int {
	return b.rows
}

func (b *nodeRecordExecutionBatch) appendMetadata(meta *metadata.CommonMetadata) {
	if meta == nil {
		b.MetaClientName.Append("")
		b.MetaClientID.Append("")
		b.MetaClientVersion.Append("")
		b.MetaClientImplementation.Append("")
		b.MetaClientOS.Append("")
		b.MetaClientIP.Append(proto.Nullable[proto.IPv6]{})
		b.MetaClientGeoCity.Append("")
		b.MetaClientGeoCountry.Append("")
		b.MetaClientGeoCountryCode.Append("")
		b.MetaClientGeoContinentCode.Append("")
		b.MetaClientGeoLongitude.Append(proto.Nullable[float64]{})
		b.MetaClientGeoLatitude.Append(proto.Nullable[float64]{})
		b.MetaClientGeoAutonomousSystemNumber.Append(proto.Nullable[uint32]{})
		b.MetaClientGeoAutonomousSystemOrganization.Append(proto.Nullable[string]{})
		b.MetaNetworkID.Append(0)
		b.MetaNetworkName.Append("")
		b.MetaLabels.Append(nil)
		return
	}

	b.MetaClientName.Append(meta.MetaClientName)
	b.MetaClientID.Append(meta.MetaClientID)
	b.MetaClientVersion.Append(meta.MetaClientVersion)
	b.MetaClientImplementation.Append(meta.MetaClientImplementation)
	b.MetaClientOS.Append(meta.MetaClientOS)
	b.MetaClientIP.Append(proto.NewNullable[proto.IPv6](flattener.ParseIPv6(meta.MetaClientIP)))
	b.MetaClientGeoCity.Append(meta.MetaClientGeoCity)
	b.MetaClientGeoCountry.Append(meta.MetaClientGeoCountry)
	b.MetaClientGeoCountryCode.Append(meta.MetaClientGeoCountryCode)
	b.MetaClientGeoContinentCode.Append(meta.MetaClientGeoContinentCode)
	b.MetaClientGeoLongitude.Append(proto.NewNullable[float64](meta.MetaClientGeoLongitude))
	b.MetaClientGeoLatitude.Append(proto.NewNullable[float64](meta.MetaClientGeoLatitude))
	b.MetaClientGeoAutonomousSystemNumber.Append(proto.NewNullable[uint32](meta.MetaClientGeoAutonomousSystemNumber))
	b.MetaClientGeoAutonomousSystemOrganization.Append(proto.NewNullable[string](meta.MetaClientGeoAutonomousSystemOrganization))
	b.MetaNetworkID.Append(int32(meta.MetaNetworkID))
	b.MetaNetworkName.Append(meta.MetaNetworkName)
	if meta.MetaLabels != nil {
		b.MetaLabels.Append(meta.MetaLabels)
	} else {
		b.MetaLabels.Append(map[string]string{})
	}
}

func (b *nodeRecordExecutionBatch) Input() proto.Input {
	return proto.Input{
		{Name: "updated_date_time", Data: &b.UpdatedDateTime},
		{Name: "event_date_time", Data: &b.EventDateTime},
		{Name: "enr", Data: &b.Enr},
		{Name: "name", Data: &b.Name},
		{Name: "version", Data: &b.Version},
		{Name: "version_major", Data: &b.VersionMajor},
		{Name: "version_minor", Data: &b.VersionMinor},
		{Name: "version_patch", Data: &b.VersionPatch},
		{Name: "implementation", Data: &b.Implementation},
		{Name: "capabilities", Data: b.Capabilities},
		{Name: "protocol_version", Data: &b.ProtocolVersion},
		{Name: "total_difficulty", Data: &b.TotalDifficulty},
		{Name: "head", Data: &b.Head},
		{Name: "genesis", Data: &b.Genesis},
		{Name: "fork_id_hash", Data: &b.ForkIDHash},
		{Name: "fork_id_next", Data: &b.ForkIDNext},
		{Name: "node_id", Data: &b.NodeID},
		{Name: "ip", Data: b.IP},
		{Name: "tcp", Data: b.Tcp},
		{Name: "udp", Data: b.Udp},
		{Name: "has_ipv6", Data: &b.HasIpv6},
		{Name: "geo_city", Data: &b.GeoCity},
		{Name: "geo_country", Data: &b.GeoCountry},
		{Name: "geo_country_code", Data: &b.GeoCountryCode},
		{Name: "geo_continent_code", Data: &b.GeoContinentCode},
		{Name: "geo_longitude", Data: b.GeoLongitude},
		{Name: "geo_latitude", Data: b.GeoLatitude},
		{Name: "geo_autonomous_system_number", Data: b.GeoAutonomousSystemNumber},
		{Name: "geo_autonomous_system_organization", Data: b.GeoAutonomousSystemOrganization},
		{Name: "meta_client_name", Data: &b.MetaClientName},
		{Name: "meta_client_id", Data: &b.MetaClientID},
		{Name: "meta_client_version", Data: &b.MetaClientVersion},
		{Name: "meta_client_implementation", Data: &b.MetaClientImplementation},
		{Name: "meta_client_os", Data: &b.MetaClientOS},
		{Name: "meta_client_ip", Data: b.MetaClientIP},
		{Name: "meta_client_geo_city", Data: &b.MetaClientGeoCity},
		{Name: "meta_client_geo_country", Data: &b.MetaClientGeoCountry},
		{Name: "meta_client_geo_country_code", Data: &b.MetaClientGeoCountryCode},
		{Name: "meta_client_geo_continent_code", Data: &b.MetaClientGeoContinentCode},
		{Name: "meta_client_geo_longitude", Data: b.MetaClientGeoLongitude},
		{Name: "meta_client_geo_latitude", Data: b.MetaClientGeoLatitude},
		{Name: "meta_client_geo_autonomous_system_number", Data: b.MetaClientGeoAutonomousSystemNumber},
		{Name: "meta_client_geo_autonomous_system_organization", Data: b.MetaClientGeoAutonomousSystemOrganization},
		{Name: "meta_network_id", Data: &b.MetaNetworkID},
		{Name: "meta_network_name", Data: &b.MetaNetworkName},
		{Name: "meta_labels", Data: b.MetaLabels},
	}
}

func (b *nodeRecordExecutionBatch) Reset() {
	b.UpdatedDateTime.Reset()
	b.EventDateTime.Reset()
	b.Enr.Reset()
	b.Name.Reset()
	b.Version.Reset()
	b.VersionMajor.Reset()
	b.VersionMinor.Reset()
	b.VersionPatch.Reset()
	b.Implementation.Reset()
	b.Capabilities.Reset()
	b.ProtocolVersion.Reset()
	b.TotalDifficulty.Reset()
	b.Head.Reset()
	b.Genesis.Reset()
	b.ForkIDHash.Reset()
	b.ForkIDNext.Reset()
	b.NodeID.Reset()
	b.IP.Reset()
	b.Tcp.Reset()
	b.Udp.Reset()
	b.HasIpv6.Reset()
	b.GeoCity.Reset()
	b.GeoCountry.Reset()
	b.GeoCountryCode.Reset()
	b.GeoContinentCode.Reset()
	b.GeoLongitude.Reset()
	b.GeoLatitude.Reset()
	b.GeoAutonomousSystemNumber.Reset()
	b.GeoAutonomousSystemOrganization.Reset()
	b.MetaClientName.Reset()
	b.MetaClientID.Reset()
	b.MetaClientVersion.Reset()
	b.MetaClientImplementation.Reset()
	b.MetaClientOS.Reset()
	b.MetaClientIP.Reset()
	b.MetaClientGeoCity.Reset()
	b.MetaClientGeoCountry.Reset()
	b.MetaClientGeoCountryCode.Reset()
	b.MetaClientGeoContinentCode.Reset()
	b.MetaClientGeoLongitude.Reset()
	b.MetaClientGeoLatitude.Reset()
	b.MetaClientGeoAutonomousSystemNumber.Reset()
	b.MetaClientGeoAutonomousSystemOrganization.Reset()
	b.MetaNetworkID.Reset()
	b.MetaNetworkName.Reset()
	b.MetaLabels.Reset()
	b.rows = 0
}

func (b *nodeRecordExecutionBatch) Snapshot() []map[string]any {
	n := b.rows
	out := make([]map[string]any, n)

	for i := 0; i < n; i++ {
		row := make(map[string]any, 46)
		row["updated_date_time"] = b.UpdatedDateTime.Row(i).Unix()
		row["event_date_time"] = b.EventDateTime.Row(i).UnixMilli()
		row["enr"] = b.Enr.Row(i)
		row["name"] = b.Name.Row(i)
		row["version"] = b.Version.Row(i)
		row["version_major"] = b.VersionMajor.Row(i)
		row["version_minor"] = b.VersionMinor.Row(i)
		row["version_patch"] = b.VersionPatch.Row(i)
		row["implementation"] = b.Implementation.Row(i)
		row["capabilities"] = b.Capabilities.Row(i)
		row["protocol_version"] = b.ProtocolVersion.Row(i)
		row["total_difficulty"] = b.TotalDifficulty.Row(i)
		row["head"] = b.Head.Row(i)
		row["genesis"] = b.Genesis.Row(i)
		row["fork_id_hash"] = b.ForkIDHash.Row(i)
		row["fork_id_next"] = b.ForkIDNext.Row(i)
		row["node_id"] = b.NodeID.Row(i)
		if v := b.IP.Row(i); v.Set {
			row["ip"] = net.IP(v.Value[:]).String()
		} else {
			row["ip"] = nil
		}
		if v := b.Tcp.Row(i); v.Set {
			row["tcp"] = v.Value
		} else {
			row["tcp"] = nil
		}
		if v := b.Udp.Row(i); v.Set {
			row["udp"] = v.Value
		} else {
			row["udp"] = nil
		}
		row["has_ipv6"] = b.HasIpv6.Row(i)
		row["geo_city"] = b.GeoCity.Row(i)
		row["geo_country"] = b.GeoCountry.Row(i)
		row["geo_country_code"] = b.GeoCountryCode.Row(i)
		row["geo_continent_code"] = b.GeoContinentCode.Row(i)
		if v := b.GeoLongitude.Row(i); v.Set {
			row["geo_longitude"] = v.Value
		} else {
			row["geo_longitude"] = nil
		}
		if v := b.GeoLatitude.Row(i); v.Set {
			row["geo_latitude"] = v.Value
		} else {
			row["geo_latitude"] = nil
		}
		if v := b.GeoAutonomousSystemNumber.Row(i); v.Set {
			row["geo_autonomous_system_number"] = v.Value
		} else {
			row["geo_autonomous_system_number"] = nil
		}
		if v := b.GeoAutonomousSystemOrganization.Row(i); v.Set {
			row["geo_autonomous_system_organization"] = v.Value
		} else {
			row["geo_autonomous_system_organization"] = nil
		}
		row["meta_client_name"] = b.MetaClientName.Row(i)
		row["meta_client_id"] = b.MetaClientID.Row(i)
		row["meta_client_version"] = b.MetaClientVersion.Row(i)
		row["meta_client_implementation"] = b.MetaClientImplementation.Row(i)
		row["meta_client_os"] = b.MetaClientOS.Row(i)
		if v := b.MetaClientIP.Row(i); v.Set {
			row["meta_client_ip"] = net.IP(v.Value[:]).String()
		} else {
			row["meta_client_ip"] = nil
		}
		row["meta_client_geo_city"] = b.MetaClientGeoCity.Row(i)
		row["meta_client_geo_country"] = b.MetaClientGeoCountry.Row(i)
		row["meta_client_geo_country_code"] = b.MetaClientGeoCountryCode.Row(i)
		row["meta_client_geo_continent_code"] = b.MetaClientGeoContinentCode.Row(i)
		if v := b.MetaClientGeoLongitude.Row(i); v.Set {
			row["meta_client_geo_longitude"] = v.Value
		} else {
			row["meta_client_geo_longitude"] = nil
		}
		if v := b.MetaClientGeoLatitude.Row(i); v.Set {
			row["meta_client_geo_latitude"] = v.Value
		} else {
			row["meta_client_geo_latitude"] = nil
		}
		if v := b.MetaClientGeoAutonomousSystemNumber.Row(i); v.Set {
			row["meta_client_geo_autonomous_system_number"] = v.Value
		} else {
			row["meta_client_geo_autonomous_system_number"] = nil
		}
		if v := b.MetaClientGeoAutonomousSystemOrganization.Row(i); v.Set {
			row["meta_client_geo_autonomous_system_organization"] = v.Value
		} else {
			row["meta_client_geo_autonomous_system_organization"] = nil
		}
		row["meta_network_id"] = b.MetaNetworkID.Row(i)
		row["meta_network_name"] = b.MetaNetworkName.Row(i)
		row["meta_labels"] = b.MetaLabels.Row(i)
		out[i] = row
	}

	return out
}
