# Horizon Progress Log

Branch: ralph/horizon
Started: 2026-01-21

## Codebase Patterns
- Use `buf generate --path <file>` when symlinks cause issues with full buf generate
- HorizonType enum values follow pattern HORIZON_TYPE_<API_PATH> (e.g., HORIZON_TYPE_BEACON_API_ETH_V2_BEACON_BLOCK)
- HorizonLocation uses simpler slot-based tracking (head_slot, fill_slot) vs Cannon's epoch-based BackfillingCheckpointMarker
- Persistence layer pattern: create `pkg/server/persistence/<module>/location.go` for struct with Marshal/Unmarshal, then `pkg/server/persistence/<module>_location.go` for client methods
- PostgreSQL migrations go in `migrations/postgres/` with sequential numbering (e.g., 009_horizon.up.sql)
- Use `sqlbuilder.Raw("DEFAULT")` for auto-increment ID fields when inserting
- ON CONFLICT constraint names follow pattern `<table>_unique`
- Shared interfaces between Cannon/Horizon go in pkg/cldata/ with subdirectories for deriver/ and iterator/
- EventDeriver interface uses CannonType() method even for shared code (Horizon will map HorizonType to equivalent CannonType)
- Iterator interface uses Position struct with both Slot and Epoch fields to support both slot-based (Horizon) and epoch-based (Cannon) processing
- Use adapter pattern to bridge module-specific types to shared interfaces (e.g., IteratorAdapter, BeaconClientAdapter, ContextProviderAdapter in v2/adapters.go)
- Position.LookAheadEpochs (not LookAheads) for epoch-based preloading to avoid type confusion
- Shared helper functions like GetBlockIdentifier, ConvertIndexedAttestation go in pkg/cldata/deriver/ and are exported for reuse
- When extending shared interfaces (BeaconClient, ContextProvider), update ALL adapters that implement them
- Blob utility functions live in pkg/cldata/blob.go (ConvertKzgCommitmentToVersionedHash, CountConsecutiveEmptyBytes)
- BeaconClient duties methods: FetchBeaconCommittee(epoch) for committee info, GetValidatorIndex(epoch, slot, committeeIndex, position) for validator lookups
- Large parameter types (like 96-byte BLSSignature) should be passed by pointer to avoid copy overhead

---

## 2026-01-21 - US-001
- What was implemented:
  - Added HorizonType enum to coordinator.proto mirroring CannonType (13 deriver types)
  - Added HorizonLocation message with network_id, type, head_slot, fill_slot fields
  - Added GetHorizonLocation and UpsertHorizonLocation RPC methods to Coordinator service
  - Generated Go code with buf generate --path
- Files changed:
  - pkg/proto/xatu/coordinator.proto (added enum, messages, RPC methods)
  - pkg/proto/xatu/coordinator.pb.go (regenerated)
  - pkg/proto/xatu/coordinator_grpc.pb.go (regenerated)
- **Learnings for future iterations:**
  - Symlinks in project root (.cursor, .roo, ai_docs, llms) cause buf generate to fail with "EvalSymlinks: too many links"
  - Use `buf generate --path pkg/proto/xatu/coordinator.proto` to work around this
  - HorizonLocation tracks dual progress (HEAD real-time + FILL catch-up) unlike Cannon's single backfill marker
---

## 2026-01-21 - US-002
- What was implemented:
  - Created PostgreSQL migration for horizon_location table (009_horizon.up.sql, 009_horizon.down.sql)
  - Created pkg/server/persistence/horizon/location.go with Location struct and Marshal/Unmarshal methods
  - Created pkg/server/persistence/horizon_location.go with UpsertHorizonLocation and GetHorizonLocationByNetworkIDAndType methods
  - Implemented GetHorizonLocation RPC handler in coordinator client
  - Implemented UpsertHorizonLocation RPC handler in coordinator client
- Files changed:
  - migrations/postgres/009_horizon.up.sql (new - creates horizon_location table)
  - migrations/postgres/009_horizon.down.sql (new - drops horizon_location table)
  - pkg/server/persistence/horizon/location.go (new - Location struct with Marshal/Unmarshal)
  - pkg/server/persistence/horizon_location.go (new - persistence client methods)
  - pkg/server/service/coordinator/client.go (added GetHorizonLocation and UpsertHorizonLocation handlers)
- **Learnings for future iterations:**
  - HorizonLocation is simpler than CannonLocation - stores head_slot and fill_slot directly without oneof Data pattern
  - Follow existing patterns: cannon/location.go and relaymonitor/location.go for struct design
  - Coordinator RPC handlers follow consistent auth check pattern at start of each method
  - Use ErrHorizonLocationNotFound sentinel error for "not found" cases (don't return nil error with nil result)
---

## 2026-01-21 - US-003
- What was implemented:
  - Created pkg/cldata/ directory structure with deriver/ and iterator/ subdirectories
  - Created pkg/cldata/deriver/interface.go with EventDeriver interface (Start, Stop, Name, CannonType, OnEventsDerived, ActivationFork)
  - Created pkg/cldata/iterator/interface.go with Iterator interface (Start, Next, UpdateLocation) and Position struct
  - Created pkg/cldata/context.go with ContextProvider interface (CreateClientMeta, NetworkName, NetworkID, Wallclock)
- Files changed:
  - pkg/cldata/context.go (new - ContextProvider interface)
  - pkg/cldata/deriver/interface.go (new - EventDeriver interface)
  - pkg/cldata/iterator/interface.go (new - Iterator interface, Position struct, Direction type, ErrLocationUpToDate)
- **Learnings for future iterations:**
  - Cannon's EventDeriver interface in pkg/cannon/deriver/event_deriver.go served as the template
  - Cannon's BackfillingCheckpoint iterator returns epoch-based positions; Horizon will use slot-based
  - Position struct includes both Slot and Epoch to support both processing modes
  - Direction type uses "forward"/"backward" instead of "head"/"backfill" for clearer semantics
  - ContextProvider abstracts network metadata needed by derivers (CreateClientMeta is key for event decoration)
---

## 2026-01-21 - US-004
- What was implemented:
  - Created pkg/cldata/beacon.go with BeaconClient interface for block fetching (GetBeaconBlock, LazyLoadBeaconBlock, Synced, Node)
  - Created shared BeaconBlockDeriver in pkg/cldata/deriver/beacon_block.go using Iterator, BeaconClient, and ContextProvider interfaces
  - Created adapters in pkg/cannon/deriver/beacon/eth/v2/adapters.go:
    - BeaconClientAdapter wraps *ethereum.BeaconNode to implement cldata.BeaconClient
    - IteratorAdapter wraps *iterator.BackfillingCheckpoint to implement cldata/iterator.Iterator
    - ContextProviderAdapter wraps client metadata to implement cldata.ContextProvider
  - Updated pkg/cannon/cannon.go to use shared BeaconBlockDeriver with adapters
  - Updated pkg/cldata/iterator/interface.go: renamed LookAheads to LookAheadEpochs for clarity
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared BeaconBlockDeriver
- Files changed:
  - pkg/cldata/beacon.go (new - BeaconClient interface)
  - pkg/cldata/deriver/beacon_block.go (new - shared BeaconBlockDeriver implementation)
  - pkg/cldata/iterator/interface.go (updated - renamed LookAheads to LookAheadEpochs)
  - pkg/cannon/deriver/beacon/eth/v2/adapters.go (new - adapter implementations)
  - pkg/cannon/cannon.go (updated - use shared deriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared deriver)
- **Learnings for future iterations:**
  - Adapter pattern is key for bridging module-specific types (BackfillingCheckpoint, BeaconNode) to shared interfaces
  - Direction enum conversion needed: BackfillingCheckpointDirectionBackfill -> DirectionBackward, DirectionHead -> DirectionForward
  - Keep Cannon's BeaconBlockDeriverConfig with Iterator field - the shared deriver's config is simpler (just Enabled)
  - ContextProviderAdapter receives pre-built clientMeta since Cannon creates it once at startup, not per-call
  - Import shadowing: avoid naming parameters same as imported packages (e.g., `beacon` parameter shadows `beacon` package)
---

## 2026-01-21 - US-005
- What was implemented:
  - Created shared AttesterSlashingDeriver in pkg/cldata/deriver/attester_slashing.go using Iterator, BeaconClient, and ContextProvider interfaces
  - Created shared GetBlockIdentifier helper in pkg/cldata/deriver/block_identifier.go for block metadata extraction
  - Created shared ConvertIndexedAttestation helper (exported) for converting VersionedIndexedAttestation to proto format
  - Updated pkg/cannon/cannon.go to use shared AttesterSlashingDeriver with adapters (same pattern as BeaconBlockDeriver)
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared AttesterSlashingDeriver
- Files changed:
  - pkg/cldata/deriver/attester_slashing.go (new - shared AttesterSlashingDeriver implementation)
  - pkg/cldata/deriver/block_identifier.go (new - GetBlockIdentifier helper for block metadata)
  - pkg/cannon/cannon.go (updated - use shared AttesterSlashingDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared AttesterSlashingDeriver)
- **Learnings for future iterations:**
  - GetBlockIdentifier is a reusable utility function that many derivers need - moved to shared package
  - ConvertIndexedAttestation is exported (capital C) since it may be needed by other slashing-related derivers
  - Shared derivers use `ctx.CreateClientMeta(ctx)` for per-call metadata vs Cannon's pre-built clientMeta
  - Use `_ context.Context` for unused context parameters to silence linter warnings
  - Follow the established adapter wiring pattern: NewIteratorAdapter(iter), NewBeaconClientAdapter(beacon), NewContextProviderAdapter(...)
---

## 2026-01-21 - US-006
- What was implemented:
  - Created shared ProposerSlashingDeriver in pkg/cldata/deriver/proposer_slashing.go using Iterator, BeaconClient, and ContextProvider interfaces
  - Updated pkg/cannon/cannon.go to use shared ProposerSlashingDeriver with adapters (same pattern as AttesterSlashingDeriver)
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared ProposerSlashingDeriver
- Files changed:
  - pkg/cldata/deriver/proposer_slashing.go (new - shared ProposerSlashingDeriver implementation)
  - pkg/cannon/cannon.go (updated - use shared ProposerSlashingDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared ProposerSlashingDeriver)
- **Learnings for future iterations:**
  - ProposerSlashing conversion is simpler than AttesterSlashing - no need for helper functions like ConvertIndexedAttestation
  - The slashing conversion directly maps phase0.ProposerSlashing fields to xatuethv1.ProposerSlashingV2
  - Follow same pattern: NewIteratorAdapter, NewBeaconClientAdapter, NewContextProviderAdapter wiring
---

## 2026-01-21 - US-007
- What was implemented:
  - Created shared DepositDeriver in pkg/cldata/deriver/deposit.go using Iterator, BeaconClient, and ContextProvider interfaces
  - Updated pkg/cannon/cannon.go to use shared DepositDeriver with adapters (same pattern as ProposerSlashingDeriver)
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared DepositDeriver
- Files changed:
  - pkg/cldata/deriver/deposit.go (new - shared DepositDeriver implementation)
  - pkg/cannon/cannon.go (updated - use shared DepositDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared DepositDeriver)
- **Learnings for future iterations:**
  - Deposit conversion extracts proof array and deposit data fields (pubkey, withdrawal_credentials, amount, signature)
  - Follow same adapter wiring pattern: NewIteratorAdapter, NewBeaconClientAdapter, NewContextProviderAdapter
  - All block-based derivers share the same structure: lookAhead, processEpoch, processSlot, getXXX, createEvent
---

## 2026-01-21 - US-008
- What was implemented:
  - Created shared WithdrawalDeriver in pkg/cldata/deriver/withdrawal.go using Iterator, BeaconClient, and ContextProvider interfaces
  - WithdrawalDeriver uses spec.DataVersionCapella as ActivationFork (withdrawals were introduced in Capella)
  - Updated pkg/cannon/cannon.go to use shared WithdrawalDeriver with adapters
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared WithdrawalDeriver
- Files changed:
  - pkg/cldata/deriver/withdrawal.go (new - shared WithdrawalDeriver implementation)
  - pkg/cannon/cannon.go (updated - use shared WithdrawalDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared WithdrawalDeriver)
- **Learnings for future iterations:**
  - Withdrawal conversion is simpler than Deposit - just 4 fields: Index, ValidatorIndex, Address, Amount
  - Capella-activated derivers use spec.DataVersionCapella as activation fork
  - Follow same adapter wiring pattern: NewIteratorAdapter, NewBeaconClientAdapter, NewContextProviderAdapter
---

## 2026-01-21 - US-009
- What was implemented:
  - Created shared VoluntaryExitDeriver in pkg/cldata/deriver/voluntary_exit.go using Iterator, BeaconClient, and ContextProvider interfaces
  - VoluntaryExitDeriver uses spec.DataVersionPhase0 as ActivationFork (voluntary exits available since genesis)
  - Updated pkg/cannon/cannon.go to use shared VoluntaryExitDeriver with adapters
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared VoluntaryExitDeriver
- Files changed:
  - pkg/cldata/deriver/voluntary_exit.go (new - shared VoluntaryExitDeriver implementation)
  - pkg/cannon/cannon.go (updated - use shared VoluntaryExitDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared VoluntaryExitDeriver)
- **Learnings for future iterations:**
  - VoluntaryExit conversion uses SignedVoluntaryExitV2 with Message containing Epoch and ValidatorIndex
  - Phase0-activated derivers use spec.DataVersionPhase0 as activation fork
  - Follow same adapter wiring pattern: NewIteratorAdapter, NewBeaconClientAdapter, NewContextProviderAdapter
---

## 2026-01-21 - US-010
- What was implemented:
  - Created shared BLSToExecutionChangeDeriver in pkg/cldata/deriver/bls_to_execution_change.go using Iterator, BeaconClient, and ContextProvider interfaces
  - BLSToExecutionChangeDeriver uses spec.DataVersionCapella as ActivationFork (BLS to execution changes were introduced in Capella)
  - Updated pkg/cannon/cannon.go to use shared BLSToExecutionChangeDeriver with adapters
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared BLSToExecutionChangeDeriver
- Files changed:
  - pkg/cldata/deriver/bls_to_execution_change.go (new - shared BLSToExecutionChangeDeriver implementation)
  - pkg/cannon/cannon.go (updated - use shared BLSToExecutionChangeDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared BLSToExecutionChangeDeriver)
- **Learnings for future iterations:**
  - BLSToExecutionChange conversion uses SignedBLSToExecutionChangeV2 with Message containing ValidatorIndex, FromBlsPubkey, ToExecutionAddress
  - Capella-activated derivers use spec.DataVersionCapella as activation fork
  - Follow same adapter wiring pattern: NewIteratorAdapter, NewBeaconClientAdapter, NewContextProviderAdapter
---

## 2026-01-21 - US-011
- What was implemented:
  - Created shared ExecutionTransactionDeriver in pkg/cldata/deriver/execution_transaction.go using Iterator, BeaconClient, and ContextProvider interfaces
  - Extended cldata.BeaconClient interface with FetchBeaconBlockBlobs method for blob sidecar fetching (needed for Deneb+ blocks)
  - Extended cldata.ContextProvider interface with DepositChainID method for execution layer chain ID access
  - Created pkg/cldata/blob.go with utility functions: ConvertKzgCommitmentToVersionedHash, CountConsecutiveEmptyBytes
  - Updated BeaconClientAdapter to implement FetchBeaconBlockBlobs method
  - Updated ContextProviderAdapter to accept and provide depositChainID
  - ExecutionTransactionDeriver uses spec.DataVersionBellatrix as ActivationFork
  - Updated pkg/cannon/cannon.go to use shared ExecutionTransactionDeriver with adapters
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared ExecutionTransactionDeriver
- Files changed:
  - pkg/cldata/beacon.go (updated - added FetchBeaconBlockBlobs to BeaconClient interface)
  - pkg/cldata/context.go (updated - added DepositChainID to ContextProvider interface)
  - pkg/cldata/blob.go (new - blob utility functions)
  - pkg/cldata/deriver/execution_transaction.go (new - shared ExecutionTransactionDeriver implementation)
  - pkg/cannon/deriver/beacon/eth/v2/adapters.go (updated - added FetchBeaconBlockBlobs, DepositChainID methods)
  - pkg/cannon/cannon.go (updated - use shared ExecutionTransactionDeriver with adapters, added depositChainID param)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared ExecutionTransactionDeriver)
- **Learnings for future iterations:**
  - ExecutionTransactionDeriver is more complex - requires blob sidecar fetching for type 3 (blob) transactions
  - Interface extension: adding new methods (FetchBeaconBlockBlobs, DepositChainID) requires updating all adapters
  - Blob utility functions (ConvertKzgCommitmentToVersionedHash, CountConsecutiveEmptyBytes) moved to shared pkg/cldata/blob.go
  - Bellatrix-activated derivers use spec.DataVersionBellatrix as activation fork (execution payload introduced)
  - GetGasPrice helper exported for potential reuse - handles type 0/1/2/3/4 transactions across block versions
  - ContextProviderAdapter constructor now requires depositChainID parameter (breaking change for existing callers)
---

## 2026-01-21 - US-012
- What was implemented:
  - Created shared ElaboratedAttestationDeriver in pkg/cldata/deriver/elaborated_attestation.go using Iterator, BeaconClient, and ContextProvider interfaces
  - Extended cldata.BeaconClient interface with FetchBeaconCommittee and GetValidatorIndex methods for duties access
  - Updated BeaconClientAdapter to implement new duties methods (delegating to Cannon's DutiesService)
  - ElaboratedAttestationDeriver uses spec.DataVersionPhase0 as ActivationFork (attestations available since genesis)
  - Handles both pre-Electra (Phase0-Deneb) and Electra+ attestations with different processing paths
  - Updated pkg/cannon/cannon.go to use shared ElaboratedAttestationDeriver with adapters
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared ElaboratedAttestationDeriver
- Files changed:
  - pkg/cldata/beacon.go (updated - added FetchBeaconCommittee and GetValidatorIndex to BeaconClient interface)
  - pkg/cldata/deriver/elaborated_attestation.go (new - shared ElaboratedAttestationDeriver implementation)
  - pkg/cannon/deriver/beacon/eth/v2/adapters.go (updated - added FetchBeaconCommittee, GetValidatorIndex methods)
  - pkg/cannon/cannon.go (updated - use shared ElaboratedAttestationDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared ElaboratedAttestationDeriver)
- **Learnings for future iterations:**
  - ElaboratedAttestationDeriver requires duties access (committee info) for validator index lookups
  - BeaconClient interface extended with FetchBeaconCommittee(epoch) and GetValidatorIndex(epoch, slot, committeeIndex, position)
  - Electra attestations have committee_bits field requiring per-committee processing; pre-Electra have single committee per attestation
  - Large parameter types (96-byte BLSSignature) should be passed by pointer to avoid copy overhead
  - Phase0-activated derivers use spec.DataVersionPhase0 as activation fork
---

## 2026-01-21 - US-013
- What was implemented:
  - Created shared ProposerDutyDeriver in pkg/cldata/deriver/proposer_duty.go using Iterator, BeaconClient, and ContextProvider interfaces
  - Extended cldata.BeaconClient interface with FetchProposerDuties method for epoch-based duty fetching
  - Updated BeaconClientAdapter to implement FetchProposerDuties method (delegating to beacon node)
  - ProposerDutyDeriver uses spec.DataVersionPhase0 as ActivationFork (proposer duties available since genesis)
  - Updated pkg/cannon/cannon.go to use shared ProposerDutyDeriver with adapters
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared ProposerDutyDeriver
- Files changed:
  - pkg/cldata/beacon.go (updated - added FetchProposerDuties to BeaconClient interface)
  - pkg/cldata/deriver/proposer_duty.go (new - shared ProposerDutyDeriver implementation)
  - pkg/cannon/deriver/beacon/eth/v2/adapters.go (updated - added FetchProposerDuties method)
  - pkg/cannon/cannon.go (updated - use shared ProposerDutyDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared ProposerDutyDeriver)
- **Learnings for future iterations:**
  - ProposerDutyDeriver is epoch-based like other v1 derivers - fetches duties for entire epoch via FetchProposerDuties
  - Unlike block-based derivers, duty derivers don't process slots individually - they get all duties for an epoch at once
  - FetchProposerDuties returns []*apiv1.ProposerDuty directly from beacon node (via Node().FetchProposerDuties)
  - Phase0-activated derivers use spec.DataVersionPhase0 as activation fork
---

## 2026-01-21 - US-014
- What was implemented:
  - Created shared BeaconBlobDeriver in pkg/cldata/deriver/beacon_blob.go using Iterator, BeaconClient, and ContextProvider interfaces
  - BeaconBlobDeriver uses spec.DataVersionDeneb as ActivationFork (blob sidecars were introduced in Deneb)
  - Uses shared blob utility functions (ConvertKzgCommitmentToVersionedHash, CountConsecutiveEmptyBytes) from pkg/cldata/blob.go
  - Updated pkg/cannon/cannon.go to use shared BeaconBlobDeriver with adapters
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared BeaconBlobDeriver
- Files changed:
  - pkg/cldata/deriver/beacon_blob.go (new - shared BeaconBlobDeriver implementation)
  - pkg/cannon/cannon.go (updated - use shared BeaconBlobDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared BeaconBlobDeriver)
- **Learnings for future iterations:**
  - BeaconBlobDeriver is epoch-based but processes slots within each epoch to fetch blobs
  - Uses FetchBeaconBlockBlobs from BeaconClient interface (already added in US-011)
  - Uses shared blob utilities from pkg/cldata/blob.go (ConvertKzgCommitmentToVersionedHash, CountConsecutiveEmptyBytes)
  - Deneb-activated derivers use spec.DataVersionDeneb as activation fork
  - Follow same adapter wiring pattern: NewIteratorAdapter, NewBeaconClientAdapter, NewContextProviderAdapter
---

## 2026-01-21 - US-015
- What was implemented:
  - Created shared BeaconValidatorsDeriver in pkg/cldata/deriver/beacon_validators.go using Iterator, BeaconClient, and ContextProvider interfaces
  - Extended cldata.BeaconClient interface with GetValidators, LazyLoadValidators, and DeleteValidatorsFromCache methods for validator state access
  - Updated BeaconClientAdapter to implement the new validator-related methods
  - BeaconValidatorsDeriver uses spec.DataVersionPhase0 as ActivationFork (validators available since genesis)
  - Updated pkg/cannon/cannon.go to use shared BeaconValidatorsDeriver with adapters
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared BeaconValidatorsDeriver
- Files changed:
  - pkg/cldata/beacon.go (updated - added GetValidators, LazyLoadValidators, DeleteValidatorsFromCache to BeaconClient interface)
  - pkg/cldata/deriver/beacon_validators.go (new - shared BeaconValidatorsDeriver implementation)
  - pkg/cannon/deriver/beacon/eth/v2/adapters.go (updated - added GetValidators, LazyLoadValidators, DeleteValidatorsFromCache methods)
  - pkg/cannon/cannon.go (updated - use shared BeaconValidatorsDeriver with adapters)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared BeaconValidatorsDeriver)
- **Learnings for future iterations:**
  - BeaconValidatorsDeriver chunks validators per configured ChunkSize to avoid large events
  - Validator cache management is important: LazyLoadValidators for lookahead, DeleteValidatorsFromCache for cleanup after processing
  - Phase0-activated derivers use spec.DataVersionPhase0 as activation fork
  - Follow same adapter wiring pattern: NewIteratorAdapter, NewBeaconClientAdapter, NewContextProviderAdapter
---

## 2026-01-21 - US-016
- What was implemented:
  - Created shared BeaconCommitteeDeriver in pkg/cldata/deriver/beacon_committee.go using Iterator, BeaconClient, and ContextProvider interfaces
  - BeaconCommitteeDeriver uses existing FetchBeaconCommittee method from BeaconClient interface (no interface changes needed)
  - BeaconCommitteeDeriver uses spec.DataVersionPhase0 as ActivationFork (committees available since genesis)
  - Updated pkg/cannon/cannon.go to use shared BeaconCommitteeDeriver with adapters
  - Removed unused v1 import from cannon.go
  - Added interface verification in pkg/cannon/deriver/event_deriver.go for shared BeaconCommitteeDeriver
- Files changed:
  - pkg/cldata/deriver/beacon_committee.go (new - shared BeaconCommitteeDeriver implementation)
  - pkg/cannon/cannon.go (updated - use shared BeaconCommitteeDeriver with adapters, removed v1 import)
  - pkg/cannon/deriver/event_deriver.go (updated - added interface check for shared BeaconCommitteeDeriver)
- **Learnings for future iterations:**
  - BeaconCommitteeDeriver is simpler than BeaconValidatorsDeriver - no chunking needed, creates one event per committee
  - FetchBeaconCommittee interface method was already added for ElaboratedAttestationDeriver (US-012) so no interface extension needed
  - Look-ahead is not supported for beacon committees (no pre-loading benefit)
  - Phase0-activated derivers use spec.DataVersionPhase0 as activation fork
  - Follow same adapter wiring pattern: NewIteratorAdapter, NewBeaconClientAdapter, NewContextProviderAdapter
---

## 2026-01-21 - US-017
- What was implemented:
  - Removed pkg/cannon/deriver/beacon/eth/v1/ directory (beacon_blob.go, beacon_committee.go, beacon_validators.go, proposer_duty.go)
  - Removed pkg/cannon/deriver/beacon/eth/v2/ directory (all 11 deriver files + adapters.go)
  - Moved adapters.go to pkg/cannon/deriver/adapters.go (same content, just relocated)
  - Updated event_deriver.go to remove v1/v2 imports and interface checks, now references only cldata shared derivers
  - Simplified config.go with unified DeriverConfig type containing Enabled and Iterator fields
  - Updated cannon.go to use deriver.NewIteratorAdapter, deriver.NewBeaconClientAdapter, deriver.NewContextProviderAdapter
  - Removed ~4,900 lines of duplicate code
- Files changed:
  - pkg/cannon/deriver/beacon/eth/v1/ (deleted - 4 files + docs)
  - pkg/cannon/deriver/beacon/eth/v2/ (deleted - 11 files + adapters + docs)
  - pkg/cannon/deriver/adapters.go (new - relocated from v2/adapters.go with package name change)
  - pkg/cannon/deriver/config.go (updated - unified DeriverConfig type)
  - pkg/cannon/deriver/event_deriver.go (updated - removed v1/v2 references)
  - pkg/cannon/cannon.go (updated - use deriver package directly for adapters)
- **Learnings for future iterations:**
  - Adapters (BeaconClientAdapter, IteratorAdapter, ContextProviderAdapter) are Cannon-specific and live in pkg/cannon/deriver/
  - Deriver config types should include both Enabled field and Iterator config for backfilling
  - BeaconValidatorsDeriverConfig is special - also has ChunkSize field
  - After moving shared code to cldata, old directories can be completely removed
  - The v1/v2 naming convention is no longer needed since all derivers use the same shared interface
---

## 2026-01-21 - US-018
- What was implemented:
  - Created pkg/horizon/ directory structure mirroring Cannon module
  - Created pkg/horizon/horizon.go with Horizon struct, New(), Start(), Shutdown() methods
  - Created pkg/horizon/config.go with Config struct, validation, and sink creation methods
  - Created pkg/horizon/metrics.go with basic Metrics struct for decorated event counting
  - Created pkg/horizon/overrides.go with Override struct for CLI flag overrides
  - Created cmd/horizon.go with 'xatu horizon' CLI subcommand
  - Added HORIZON = 11 to ModuleName enum in pkg/proto/xatu/module.proto
  - Module logs startup message with version and instance ID
  - Implements graceful shutdown on SIGTERM/SIGINT
- Files changed:
  - pkg/proto/xatu/module.proto (added HORIZON = 11)
  - pkg/proto/xatu/module.pb.go (regenerated)
  - pkg/horizon/horizon.go (new - main module with Start/Stop lifecycle)
  - pkg/horizon/config.go (new - Config struct with Validate, CreateSinks, ApplyOverrides)
  - pkg/horizon/metrics.go (new - Metrics struct with AddDecoratedEvent)
  - pkg/horizon/overrides.go (new - Override struct for CLI overrides)
  - cmd/horizon.go (new - cobra command for 'xatu horizon' subcommand)
- **Learnings for future iterations:**
  - Horizon module follows same structure as Cannon: main.go, config.go, metrics.go, overrides.go
  - ModuleName enum in module.proto assigns unique IDs to each module (HORIZON = 11)
  - CLI command pattern uses override structs for environment variable and flag handling
  - Startup message uses emoji specific to module personality (Cannon uses ðŸ’£, Horizon uses ðŸŒ…)
  - Config validation is minimal for skeleton - will be expanded in US-031
---

## 2026-01-21 - US-019
- What was implemented:
  - Added Horizon-specific metrics to pkg/horizon/metrics.go
  - Added head_slot gauge (tracks current HEAD slot position per deriver/network)
  - Added fill_slot gauge (tracks current FILL slot position per deriver/network)
  - Added lag_slots gauge (tracks slots FILL is behind HEAD per deriver/network)
  - Added blocks_derived_total counter (tracks blocks derived per deriver/network/iterator)
  - Metrics server was already configured in US-018 via ServeMetrics() on metricsAddr
- Files changed:
  - pkg/horizon/metrics.go (updated - added gauges and counter with helper methods)
- **Learnings for future iterations:**
  - Prometheus GaugeVec uses Set() for absolute values, CounterVec uses Add() for increments
  - Use consistent label naming: "deriver", "network", "iterator" for tracking dimensions
  - All Horizon metrics use "xatu_horizon" namespace prefix
  - Metrics registration uses prometheus.MustRegister() with variadic args for multiple metrics
---

## 2026-01-21 - US-020
- What was implemented:
  - Created pkg/horizon/ethereum/ directory with three files: beacon.go, config.go, metrics.go
  - BeaconNodeConfig struct holds name, address, headers for a single beacon node
  - Config struct holds array of BeaconNodeConfig plus pool-level settings (health check interval, cache settings)
  - BeaconNodePool manages multiple beacon nodes with health checking and failover
  - BeaconNodeWrapper wraps individual nodes with health status tracking
  - Health checks run periodically using sync state from ethpandaops/beacon library
  - Shared services (MetadataService, DutiesService) initialized from first healthy node
  - Block cache shared across all nodes with singleflight for deduplication
  - Metrics: beacon_node_status (gaugevec), blocks_fetched_total, block_cache_hits/misses, block_fetch_errors, health_check_total, health_check_duration
  - Updated Horizon config.go to include Ethereum configuration
  - Updated overrides.go with BeaconNodeURLs, BeaconNodeHeaders, NetworkName overrides
- Files changed:
  - pkg/horizon/ethereum/beacon.go (new - BeaconNodePool with health checking, block caching)
  - pkg/horizon/ethereum/config.go (new - BeaconNodeConfig, Config structs)
  - pkg/horizon/ethereum/metrics.go (new - Metrics struct with beacon node status tracking)
  - pkg/horizon/config.go (updated - added Ethereum config field, validation)
  - pkg/horizon/overrides.go (updated - added beacon node override support)
- **Learnings for future iterations:**
  - BeaconNodePool reuses cannon/ethereum/services (MetadataService, DutiesService) for consistency
  - Health checking uses beacon.Node.Status().SyncState().SyncDistance to determine health
  - Use singleflight.Group to prevent duplicate block fetches across concurrent requests
  - SetBeaconNodeStatus sets gauge to 1 for active status, 0 for others (multi-status pattern)
  - services.NewMetadataService returns value, take address for pointer: `metadata := services.NewMetadataService(...); p.metadata = &metadata`
  - Use goroutine parameter capture pattern: `go func(w *Wrapper) { ... }(wrapper)` for clarity
  - For loop uint64 conversion: use `for i := uint64(0); i < config.Workers; i++` not `int(config.Workers)`
---

## 2026-01-21 - US-021
- What was implemented:
  - Added exponential backoff retry logic for beacon node connections using cenkalti/backoff/v5
  - Added startNodeWithRetry method that retries failed connections with exponential backoff (1s initial, 30s max interval)
  - Added PreferNode(nodeAddress) method that prefers a specific node but falls back to any healthy node
  - Added NodeState enum (Disconnected, Connecting, Connected, Reconnecting) for connection state tracking
  - Added GetState() and Address() helper methods to BeaconNodeWrapper
  - Updated Start() to use startNodeWithRetry for all beacon nodes
- Files changed:
  - pkg/horizon/ethereum/beacon.go (updated - added retry logic, PreferNode, NodeState enum)
- **Learnings for future iterations:**
  - cenkalti/backoff/v5 API: use backoff.Retry(ctx, operation, retryOpts...) with backoff.WithBackOff(bo) and backoff.WithNotify(fn)
  - backoff v5 does not have MaxElapsedTime field; just set InitialInterval and MaxInterval on ExponentialBackOff
  - Use backoff.Permanent(err) to stop retrying on fatal errors (context cancellation, shutdown)
  - The ethpandaops/beacon library handles its own internal reconnection, so we only need retry at the initial Start() level
---

## 2026-01-21 - US-022
- What was implemented:
  - Created pkg/horizon/subscription/block.go with BlockSubscription struct
  - BlockEvent struct contains Slot, BlockRoot, ExecutionOptimistic, ReceivedAt, NodeName fields
  - Uses ethpandaops/beacon library's OnBlock callback to receive SSE block events
  - Library handles SSE connection management, reconnection with backoff, and payload parsing
  - Events emitted to buffered channel (configurable buffer size, default 1000)
  - Metrics: sse_events_total, sse_connection_status, sse_reconnects_total, sse_last_event_received_at, sse_event_processing_delay_seconds
  - Config struct with BufferSize field and validation
- Files changed:
  - pkg/horizon/subscription/block.go (new - BlockSubscription with SSE event handling and metrics)
- **Learnings for future iterations:**
  - The ethpandaops/beacon library provides OnBlock, OnHead, OnAttestation, etc. callbacks for SSE events
  - SSE connection management (reconnection, backoff) is handled internally by the beacon library
  - Use non-blocking channel send with default case to avoid blocking on full channels
  - Track processing delay by comparing receivedAt with slot start time from Wallclock
  - Sentry module uses similar pattern with beacon.Node().OnBlock() for SSE subscriptions
---

## 2026-01-21 - US-023
- What was implemented:
  - Created pkg/horizon/cache/dedup.go with DedupCache struct for block event deduplication
  - Uses jellydator/ttlcache/v3 library (same pattern as sentry, relaymonitor, mimicry caches)
  - DedupCache has configurable TTL (default 13 minutes to cover ~1 epoch plus delays)
  - Check(blockRoot) returns true if seen (duplicate), false if new (first occurrence)
  - On first occurrence, block root is automatically added to cache with TTL
  - Config struct with TTL field and Validate method (sets default if TTL <= 0)
  - Metrics struct with dedup_hits_total, dedup_misses_total, dedup_cache_size
  - Start() and Stop() methods for cache cleanup goroutine lifecycle
- Files changed:
  - pkg/horizon/cache/dedup.go (new - DedupCache with TTL-based block root deduplication and metrics)
- **Learnings for future iterations:**
  - Use jellydator/ttlcache/v3 for TTL-based caching (consistent with codebase pattern)
  - Cache.Start() runs cleanup goroutine, call in `go cache.Start()` pattern
  - TTL of 13 minutes covers slightly more than 1 epoch (6.4 min) to handle delayed events
  - Metrics pattern: hits_total (duplicates dropped), misses_total (new items processed), cache_size (current entries)
  - Check() combines get and set atomically - if not present, add; return whether was present
---

## 2026-01-21 - US-024
- What was implemented:
  - Created pkg/horizon/coordinator/ directory with config.go and client.go
  - Config struct has Address (string), Headers (map[string]string), TLS (bool) fields
  - Client struct wraps gRPC CoordinatorClient with connection management
  - New() creates client with TLS or insecure credentials based on config
  - Start() and Stop() for lifecycle management
  - GetHorizonLocation(ctx, typ HorizonType, networkID string) returns *HorizonLocation
  - UpsertHorizonLocation(ctx, location *HorizonLocation) updates or creates location
  - All methods use gzip compression and support auth headers via metadata
- Files changed:
  - pkg/horizon/coordinator/config.go (new - Config struct with Validate)
  - pkg/horizon/coordinator/client.go (new - Client with GetHorizonLocation, UpsertHorizonLocation)
- **Learnings for future iterations:**
  - Horizon coordinator client follows exact same pattern as Cannon's pkg/cannon/coordinator/
  - Use grpc.NewClient instead of deprecated grpc.Dial for new code
  - metadata.New(headers) and metadata.NewOutgoingContext for passing auth headers
  - grpc.UseCompressor(gzip.Name) for compression on all RPC calls
---

## 2026-01-21 - US-025
- What was implemented:
  - Created pkg/horizon/iterator/head.go with HeadIterator struct
  - HeadIterator implements cldata Iterator interface (Start, Next, UpdateLocation)
  - Receives block events from SSE subscription channel (deduplicated)
  - Uses DedupCache to check for duplicate block roots
  - Checks coordinator for already-processed slots before returning position
  - Creates Position structs with Slot, Epoch, Direction for derivers
  - UpdateLocation persists head_slot to coordinator, preserves fill_slot
  - HeadIteratorConfig with Enabled field for configuration
  - HeadIteratorMetrics with processed_total, skipped_total, position_slot metrics
  - ErrIteratorClosed and ErrSlotSkipped sentinel errors for control flow
- Files changed:
  - pkg/horizon/iterator/head.go (new - HeadIterator implementation with metrics)
- **Learnings for future iterations:**
  - Use sentinel errors (ErrSlotSkipped) instead of returning nil error with nil value to satisfy linters
  - Pass large structs (like BlockEvent, 88 bytes) by pointer to avoid copy overhead
  - Avoid shadowing imported package names (e.g., don't name a variable `spec` when importing `github.com/attestantio/go-eth2-client/spec`)
  - HeadIterator receives events from subscription.BlockEvent channel, not directly from SSE
  - checkActivationFork uses beaconSpec.ForkEpochs.GetByName() to get fork epoch for DataVersion
  - Position.Epoch calculation assumes 32 slots per epoch (standard beacon chain constant)
---

## 2026-01-21 - US-026
- What was implemented:
  - Created pkg/horizon/iterator/fill.go with FillIterator struct implementing cldata Iterator interface
  - FillIterator walks slots from fill_slot position toward HEAD - LAG
  - FillIteratorConfig with configurable LagSlots (default 32), MaxBoundedSlots (default 7200), RateLimit (default 10.0 slots/sec)
  - Rate limiting using golang.org/x/time/rate to avoid overwhelming beacon nodes
  - Bounded range limiting - jumps forward if too far behind HEAD
  - FillIteratorMetrics with processed_total, skipped_total, position_slot, target_slot, slots_remaining, rate_limit_wait_total, cycles_complete_total
  - Helper methods setCurrentSlot() and incrementCurrentSlot() for atomic slot updates
  - UpdateLocation updates fill_slot in coordinator, preserves head_slot
- Files changed:
  - pkg/horizon/iterator/fill.go (new - FillIterator implementation with rate limiting and metrics)
- **Learnings for future iterations:**
  - Use golang.org/x/time/rate for rate limiting: rate.NewLimiter(rate.Limit(rps), 1) and limiter.Wait(ctx)
  - Linter rule "no shared variables above expr" requires whitespace before expressions when previous line doesn't share variables
  - Use helper methods (setCurrentSlot, incrementCurrentSlot) with defer mutex.Unlock() pattern to avoid lint issues with Lock/Unlock blocks
  - FillIterator uses DirectionBackward since it processes historical data (filling gaps)
  - getWallclockHeadSlot() uses metadata.Wallclock().Slots().Current().Number() for current slot
  - When caught up to target (HEAD - LAG), wait roughly one slot duration (12 seconds) before checking again
---

## 2026-01-21 - US-027
- What was implemented:
  - Created pkg/horizon/iterator/coordinator.go with Coordinator struct managing dual HEAD and FILL iterators
  - HEAD iterator runs in dedicated goroutine with priority for real-time SSE block events
  - FILL iterator runs in separate goroutine, never blocks HEAD
  - Both iterators coordinate through the coordinator service to skip slots processed by the other
  - Updated HeadIterator.isSlotProcessed to check both head_slot and fill_slot
  - Updated FillIterator to check both head_slot and fill_slot before processing (isSlotProcessedByHead method)
  - CoordinatorConfig with Head and Fill sub-configs for enabling/disabling each iterator
  - CoordinatorMetrics with head_running and fill_running gauges for monitoring
- Files changed:
  - pkg/horizon/iterator/coordinator.go (new - Coordinator struct with Start/Stop lifecycle)
  - pkg/horizon/iterator/head.go (updated - isSlotProcessed now checks both head_slot and fill_slot)
  - pkg/horizon/iterator/fill.go (updated - added isSlotProcessedByHead method, fixed variable shadowing)
- **Learnings for future iterations:**
  - Both iterators must check both slot markers to avoid processing duplicates
  - HEAD checks slot <= head_slot OR slot <= fill_slot (skips if either processed it)
  - FILL checks slot <= head_slot OR slot <= fill_slot (skips if either processed it)
  - Variable shadowing in Go: use distinct names (rateLimitErr, forkErr) instead of reusing `err` in if statements
  - Coordinator pattern: parent goroutine spawns worker goroutines with WaitGroup for graceful shutdown
  - Use separate done channel + ctx.Done() for dual shutdown signal detection
---

## 2026-01-21 - US-028
- What was implemented:
  - Created pkg/horizon/deriver/adapters.go with BeaconClientAdapter and ContextProviderAdapter
  - BeaconClientAdapter wraps BeaconNodePool to implement cldata.BeaconClient interface
  - ContextProviderAdapter wraps Horizon's metadata to implement cldata.ContextProvider with ModuleName_HORIZON
  - Created pkg/horizon/deriver/config.go with DeriverConfig and per-deriver enable flags
  - Updated pkg/horizon/config.go with Derivers, DedupCache, Subscription, and Coordinator config fields
  - Wired all 9 block-based derivers in horizon.go onBeaconPoolReady callback:
    - BeaconBlockDeriver, AttesterSlashingDeriver, ProposerSlashingDeriver
    - DepositDeriver, WithdrawalDeriver, VoluntaryExitDeriver
    - BLSToExecutionChangeDeriver, ExecutionTransactionDeriver, ElaboratedAttestationDeriver
  - Each deriver gets its own HeadIterator instance for independent location tracking
  - Added startDeriverWhenReady method for fork-aware deriver activation
  - Events routed to configured sinks via handleNewDecoratedEvents callback
- Files changed:
  - pkg/horizon/deriver/adapters.go (new - BeaconClientAdapter, ContextProviderAdapter)
  - pkg/horizon/deriver/config.go (new - DeriverConfig, Config with enable flags)
  - pkg/horizon/config.go (updated - added Derivers, DedupCache, Subscription, Coordinator configs)
  - pkg/horizon/horizon.go (updated - full deriver wiring with onBeaconPoolReady lifecycle)
- **Learnings for future iterations:**
  - Each deriver needs its own HeadIterator instance - don't share iterators between derivers
  - BlockSubscription.Events() returns <-chan BlockEvent for reading (not the raw channel)
  - Use h.beaconPool.Metadata().Spec.ForkEpochs.GetByName() directly, not .Spec.Spec()
  - Go 1.22+ no longer needs loop variable copy (d := d) - gopls modernize linter catches this
  - createHeadIterator helper function avoids repetitive iterator construction code
  - ContextProviderAdapter creates fresh ClientMeta on each call (not pre-built like Cannon)
---

## 2026-01-21 - US-029
- What was implemented:
  - Created pkg/horizon/iterator/epoch.go with EpochIterator struct implementing cldata Iterator interface
  - EpochIterator triggers at configurable percentage through current epoch (TriggerPercent, default 50%)
  - When triggered, returns the NEXT epoch for processing (pre-fetching pattern)
  - EpochIteratorConfig struct with Enabled and TriggerPercent fields
  - Tracks last processed epoch in coordinator using HorizonLocation.HeadSlot field
  - Added epoch-based deriver configs to pkg/horizon/deriver/config.go:
    - ProposerDutyConfig, BeaconBlobConfig, BeaconValidatorsConfig (with ChunkSize), BeaconCommitteeConfig
  - Added EpochIterator config to pkg/horizon/config.go
  - Added createEpochIterator helper function in horizon.go
  - Wired all 4 epoch-based derivers in horizon.go onBeaconPoolReady callback:
    - ProposerDutyDeriver (Phase0+)
    - BeaconBlobDeriver (Deneb+)
    - BeaconValidatorsDeriver (Phase0+, with ChunkSize config)
    - BeaconCommitteeDeriver (Phase0+)
- Files changed:
  - pkg/horizon/iterator/epoch.go (new - EpochIterator with midway-fetch timing)
  - pkg/horizon/deriver/config.go (updated - added epoch-based deriver configs)
  - pkg/horizon/config.go (updated - added EpochIterator config)
  - pkg/horizon/horizon.go (updated - wired epoch-based derivers with createEpochIterator helper)
- **Learnings for future iterations:**
  - EpochIterator uses wallclock to calculate trigger time based on TriggerPercent
  - Returns NEXT epoch (current + 1) so derivers can pre-fetch data before epoch starts
  - Uses HorizonLocation.HeadSlot to store last processed epoch (reuses existing proto message)
  - EpochIterator.Validate() ensures TriggerPercent is between 0 and 1 (exclusive)
  - waitForTriggerPoint() calculates exact trigger time and sleeps until then
  - Each epoch deriver gets its own EpochIterator instance for independent tracking
  - Use prometheus.Register (not MustRegister) to handle duplicate metric registration gracefully
---

## 2026-01-21 - US-030
- What was implemented:
  - Created pkg/horizon/subscription/reorg.go with ReorgSubscription struct for chain reorg SSE events
  - ReorgEvent struct with Slot, Depth, OldHeadBlock, NewHeadBlock, OldHeadState, NewHeadState, Epoch, ReceivedAt, NodeName
  - ReorgSubscription subscribes to all beacon nodes using node.OnChainReOrg() callback
  - ReorgConfig with Enabled (default true), MaxDepth (default 64 slots), BufferSize (default 100)
  - Reorg events exceeding MaxDepth are logged, ignored, and tracked with reorg_ignored_total metric
  - Added DedupCache.Delete() method to pkg/horizon/cache/dedup.go for clearing block roots
  - Added reorg config field to pkg/horizon/config.go with validation
  - Added reorgSubscription field to Horizon struct
  - Added handleReorgEvents() goroutine that reads from reorg channel and clears old head block from dedup cache
  - Comprehensive metrics: reorg_events_total, reorg_depth histogram, reorg_ignored_total, last_event_at, last_depth, last_slot
- Files changed:
  - pkg/horizon/subscription/reorg.go (new - ReorgSubscription with SSE event handling and metrics)
  - pkg/horizon/cache/dedup.go (updated - added Delete method)
  - pkg/horizon/config.go (updated - added Reorg config field and validation)
  - pkg/horizon/horizon.go (updated - added reorgSubscription, handleReorgEvents, shutdown logic)
- **Learnings for future iterations:**
  - The ethpandaops/beacon library provides OnChainReOrg() callback for chain reorg SSE events (capital R in ReOrg)
  - eth2v1.ChainReorgEvent contains Slot, Depth, OldHeadBlock, NewHeadBlock, OldHeadState, NewHeadState, Epoch
  - When a reorg occurs, clear the OLD head block root from dedup cache to allow re-processing
  - The new canonical block will be received via the block subscription SSE and processed normally
  - ReorgSubscription.Enabled() method allows checking if reorg handling is enabled before starting handler goroutine
  - Reorg depth limit prevents processing extremely deep reorgs (default 64 slots is ~2 epochs)
---

## 2026-01-21 - US-031
- What was implemented:
  - Added validation to ensure at least one output sink is configured in pkg/horizon/config.go
  - Verified all other acceptance criteria validations were already in place:
    - At least one beacon node URL: ethereum/config.go line 55-57
    - Coordinator address: coordinator/config.go line 18-20
    - LAG distance positive: iterator/fill.go line 44-48 (sets default to 32 if 0)
    - TTL positive duration: cache/dedup.go line 33-38 (sets default to 13min if <= 0)
  - All validation error messages are clear and contextualized with field names
- Files changed:
  - pkg/horizon/config.go (updated - added output sink count validation)
- **Learnings for future iterations:**
  - The Horizon config validation follows a "fail fast" pattern - returns error on first validation failure
  - Sub-package configs use "set default if invalid" pattern (LAG, TTL) rather than returning errors for better UX
  - This is consistent with the Cannon module's approach to configuration validation
  - All validation happens during startup before any goroutines are spawned
---

